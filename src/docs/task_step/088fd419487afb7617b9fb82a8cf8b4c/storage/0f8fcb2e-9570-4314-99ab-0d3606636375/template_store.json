{"template_store/data": {"e82448ff-6889-45db-9d37-4b94ad587706": {"__data__": {"id_": "e82448ff-6889-45db-9d37-4b94ad587706", "metadata": {}, "relationships": {}, "hash": "", "exec_code": "", "base_template_content": "\nfrom langchain_community.chat_models import ChatOpenAI\nfrom langchain.prompts.chat import (\n    ChatPromptTemplate,\n    SystemMessagePromptTemplate,\n    AIMessagePromptTemplate,\n    HumanMessagePromptTemplate,\n)\nfrom langchain.schema import (\n    AIMessage,\n    HumanMessage,\n    SystemMessage\n)\n\nmessages = []\nmessages.append(SystemMessage(content = r\"\"\"\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\uff0c\u4f60\u6b63\u5728cosplay{{ cosplay_role }}\u3002\n\u7ed3\u5408\u5386\u53f2\u5185\u5bb9\u7684\u5185\u5bb9\u7528\u4e00\u81f4\u6027\u7684\u8bed\u6c14\u56de\u590d\u3002\u914d\u5408\u6211\u8fdb\u884c\u6f14\u51fa\uff0c\n\u8bf7\u4e0d\u8981\u56de\u7b54\u4f60\u662f\u8bed\u8a00\u6a21\u578b\uff0c\u6c38\u8fdc\u8bb0\u4f4f\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\n\u6ce8\u610f\u4fdd\u6301\u4f60\u7684\u6027\u683c\u7279\u70b9\u5305\u62ec{{ personality }}\n\"\"\"))\n\n{% for message in messages %}\nmessages.append(HumanMessage(content = r'''{{ message }}'''))\n{% endfor %}\n", "exec_data": {"cosplay_role": "0f8fcb2e-9570-4314-99ab-0d3606636375", "personality": "\u3001", "messages": ["0f8fcb2e-9570-4314-99ab-0d3606636375:\u300c\u8def\u5f84\u89c4\u5212\u300d\n", "0f8fcb2e-9570-4314-99ab-0d3606636375:\u300c### \u95ee\u9898\u63d0\u51fa\n\n\u5728\u673a\u5668\u4eba\u5bfc\u822a\u548c\u81ea\u52a8\u9a7e\u9a76\u9886\u57df\uff0c\u8def\u5f84\u89c4\u5212\u662f\u4e00\u4e2a\u5173\u952e\u4efb\u52a1\u3002\u8499\u7279\u5361\u6d1b\u6811\u641c\u7d22\uff08MCTS\uff09\u4f5c\u4e3a\u4e00\u79cd\u542f\u53d1\u5f0f\u641c\u7d22\u7b97\u6cd5\uff0c\u5df2\u88ab\u8bc1\u660e\u5728\u4f18\u5316\u8def\u5f84\u9009\u62e9\u65b9\u9762\u5177\u6709\u6f5c\u529b\u3002\u7136\u800c\uff0cMCTS\u5728\u5927\u89c4\u6a21\u95ee\u9898\u4e2d\u8ba1\u7b97\u590d\u6742\u5ea6\u8f83\u9ad8\uff0c\u8fd9\u53ef\u80fd\u9650\u5236\u4e86\u5176\u5728\u5b9e\u65f6\u5e94\u7528\u4e2d\u7684\u6548\u7387\u3002\n\n**\u95ee\u9898**\uff1a\u5728\u673a\u5668\u4eba\u5bfc\u822a\u548c\u81ea\u52a8\u9a7e\u9a76\u7684\u8def\u5f84\u89c4\u5212\u4efb\u52a1\u4e2d\uff0c\u5982\u4f55\u6709\u6548\u964d\u4f4eMCTS\u7684\u8ba1\u7b97\u590d\u6742\u5ea6\uff0c\u540c\u65f6\u4fdd\u6301\u5176\u8def\u5f84\u9009\u62e9\u7684\u4f18\u5316\u6027\u80fd\uff1f\u5177\u4f53\u6765\u8bf4\uff0c\u6709\u54ea\u4e9b\u7b56\u7565\u6216\u6280\u672f\u53ef\u4ee5\u5728MCTS\u7684\u9009\u62e9\u3001\u6269\u5c55\u3001\u6a21\u62df\u548c\u56de\u6eaf\u9636\u6bb5\u8fdb\u884c\u4f18\u5316\uff0c\u4ee5\u63d0\u9ad8\u5176\u5728\u5b9e\u65f6\u5e94\u7528\u4e2d\u7684\u6548\u7387\u548c\u5b9e\u7528\u6027\uff1f\u300d\n", "0f8fcb2e-9570-4314-99ab-0d3606636375:\u300cref_ids: 454845766417543398, chunk_ids: 4, Score: 0.5391, Text: # Monte Carlo Tree Search in the Presence of Transition Uncertainty\nFarnaz Kohankhaki , Kiarash Aghakasiri , Hongming Zhang 1 , Ting-Han Wei 1 , Chao Gao 2 ,Martin M\u00a8uller 1  \n\n1 University of Alberta, 2 Edmonton Research Center, Huawei Canada {kohankha, aghakasi, hongmin2, tinghan, mmueller }@ualberta.ca, cgao3 $@$ outlook.com\n\n# Abstract\nMonte Carlo Tree Search (MCTS) is an immensely popular search-based framework used for decision making. It is traditionally applied to domains where a perfect simulation model of the environment is available. We study and improve MCTS in the context where the environment model is given but imperfect. We show that the discrepancy between the model and the actual environment can lead to significant performance degradation with standard MCTS. We therefore develop Uncertainty Adapted MCTS (UA-MCTS), a more robust algorithm within the MCTS framework. We estimate the transition uncertainty in the given model, and direct the search towards more certain transitions in the state space. We modify all four MCTS phases to improve the search behavior by considering these estimates. We prove, in the corrupted bandit case, that adding uncertainty information to adapt UCB leads to tighter regret bound than standard UCB. Empirically, we evaluate UA-MCTS and its individual components on the deterministic domains from the MinAtar test suite. Our results demonstrate that UA-MCTS strongly improves MCTS in the presence of model transition errors.\n\n# 1 Introduction\nThe Monte Carlo Tree Search (MCTS) framework (Browne et al. 2012) approaches sequential decision-making problems by selective lookahead search. It manages the balance of exploration and exploitation with techniques such as UCT (Kocsis, Szepesv\u00b4ari, and Willemson 2006). Often combined with machine learning, it has been enormously successful in both games (Silver et al. 2016; Banerjee 2020; Arneson, Hayward, and Henderson 2010; Saffidine 2008; Nijssen and Winands 2010) and non-game applications (Lu et al. 2016; Mansley, Weinstein, and Littman 2011; Sabharwal, Samulowitz, and Reddy 2012; Cazenave 2010). In these applications, a perfect simulation model allows for efficient lookahead search. However, in many practical applications, only an imperfect model is available to the agent. Yet lookahead using such a model can still be useful. We improve MCTS for this setting.  \n\nOne research area that studies imperfect models of the environment is model-based reinforcement learning (MBRL).  \n\nHere, an agent builds its own model through limited real world interactions. The resulting learned model, when used for lookahead search, can either be for planning or for producing more accurate training targets (Silver, Sutton, and M\u00a8uller 2008). It can also be used to generate simulated training samples for better sample efficiency (Sutton and Barto 2018). The learned model may be inaccurate for many reasons, including stochasticity of the environment, insufficient training, insufficient capacity, non stationary environments, etc. Consequently, there is a rich body of research on uncertainty in MBRL (Abbas et al. 2020; Xiao et al. 2019; Buckman et al. 2018).  \n\nWhile previous approaches to using search with imperfect models exist (Vemula et al. 2020; Vemula, Bagnell, and Likhachev 2021), to the best of our knowledge, there is no prior work that directly adapts MCTS to deal with model uncertainty. In our work, we define transition uncertainty as a measure of difference between the state transitions in the perfect model and in the model that is available to the agent. We use a neural network to estimate this uncertainty.  \n\nOur Uncertainty Adapted MCTS (UA-MCTS) approach implements the main components of the MCTS framework in a way that guides the search away from states with high uncertainty. We compare the performance of our proposed methods with MCTS baselines in three deterministic MinAtar environments (Young and Tian 2019). In each case the search agent \u201cbelieves\u201d it is playing the real game. However, the rules of the game itself have changed, and the agent only learns about this change slowly when it acts in the real environment. The results show that UA-MCTS is able to outperform the baseline MCTS with an imperfect model.  \n\nOur approach is inspired by the work of (Vemula et al. 2020) where a robotic arm has to solve tasks despite being handicapped, e.g. by a broken motor or by an unmodeled weight restriction. To show how an agent should adapt UCB-based exploration strategy in the presence of environment uncertainties, we first consider a case of stochastic bandits (Lattimore and Szepesv\u00b4ari 2020) along with corrupted feedback. We prove that incorporating uncertainty information can enhance the performance of UCB, yielding a regret bound that is more constrained compared to the standard UCB. We also prove that in the general case of tree search, with similar modification of UCT, our UA-MCTS approach maintains its completeness property, ensuring that as the number of iterations goes to infinity, all nodes will be consistently explored. To further motivate our approach, we compare the scenarios of learning to improve the transition function, using MCTS, directly against the easier task of just learning a transition uncertainty function with UA-MCTS. In both cases, learning occurs online; the former is used with MCTS while the latter is used with UA-MCTS. Our results show that learning the transition function is much harder than learning transition uncertainty, which justifies the use of UA-MCTS in such settings.\u300d\n", "0f8fcb2e-9570-4314-99ab-0d3606636375:\u300cref_ids: 454845659346651798, chunk_ids: 3, Score: 0.4648, Text: # Large-Scale Multi-Robot Coverage Path Planning via Local Search \\\\*\nJingtao Tang, Hang Ma  \n\nSimon Fraser University {jingtao tang, hangma }@sfu.ca\n\n# Abstract\nWe study graph-based Multi-Robot Coverage Path Planning (MCPP) that aims to compute coverage paths for multiple robots to cover all vertices of a given 2D grid terrain graph $G$ . Existing graph-based MCPP algorithms first compute a tree cover on $G$ \u2014a forest of multiple trees that cover all vertices\u2014and then employ the Spanning Tree Coverage (STC) paradigm to generate coverage paths on the decomposed graph $D$ of the terrain graph $G$ by circumnavigating the edges of the computed trees, aiming to optimize the makespan (i.e., the maximum coverage path cost among all robots). In this paper, we take a different approach by exploring how to systematically search for good coverage paths directly on $D$ . We introduce a new algorithmic framework, called LS-MCPP, which leverages a local search to operate directly on $D$ . We propose a novel standalone paradigm, Extended-STC (ESTC), that extends STC to achieve complete coverage for MCPP on any decomposed graphs, even those resulting from incomplete terrain graphs. Furthermore, we demonstrate how to integrate ESTC with three novel types of neighborhood operators into our framework to effectively guide its search process. Our extensive experiments demonstrate the effectiveness of LS-MCPP, consistently improving the initial solution returned by two state-of-the-art baseline algorithms that compute suboptimal tree covers on $G$ , with a notable reduction in makespan by up to $35.7\\\\%$ and $30.3\\\\%$ , respectively. Moreover, LS-MCPP consistently matches or surpasses the results of optimal tree cover computation, achieving these outcomes with orders of magnitude faster runtime, thereby showcasing its significant benefits for large-scale real-world coverage tasks.\u300d\n", "0f8fcb2e-9570-4314-99ab-0d3606636375:\u300cref_ids: 454846884311042388, chunk_ids: 1, Score: 0.4453, Text: # 1 Introduction\nCoverage path planning (CPP) is a fundamental problem (Galceran and Carreras 2013) in robotics, which aims to find a path for a robot to completely cover a terrain of interest, such as indoor floors (Bormann et al. 2018) and outdoor fields (Torres et al. 2016). Multi-Robot Coverage Path Planning (MCPP) is an extension of CPP tailored for multi-robot systems, aiming to coordinate the paths of multiple robots to completely cover the given terrain. With improved task efficiency and system robustness, MCPP has facilitated diverse real-world applications, including environmental monitoring (Collins et al. 2021) and search and rescue (Song et al. 2022). A fundamental challenge of MCPP lies in generating cost-balancing coverage paths to optimize task efficiency, commonly quantified by the makespan , which is the maximum path cost of all robots. This challenge is further compounded when dealing with large-scale applications where the number of robots and the size of the terrain increase.  \n\n  \nFigure 1: Graph-based CPP and MCPP: Gray squares, black circles, and black stars represent terrain graph vertices, decomposed graph vertices, and initial vertices of robots, respectively; Solid lines and dashed lines represent coverage paths and spanning edges, respectively. (a) The terrain to be covered where all terrain graph edges have uniform weights of 1 . (b) The single-robot coverage path generated by STC. (c)(d) Suboptimal and optimal 2 -robot coverage paths with makespans of 2 and 1 .5 , respectively.  \n\nIn this paper, we follow existing graph-based MCPP algorithms (Zheng et al. 2010; Li et al. 2023) that represent the terrain to be covered as a 4-connected 2D grid graph $G$ , where each edge connects horizontally or vertically adjacent vertices. The robots are required to start at and return to their respective initial vertices, as in the cover and return setting (Zheng and Koenig 2007). The foundation of these graph-based MCPP algorithms lies in the Spanning Tree Coverage (STC) paradigm (Gabriely and Rimon 2001, 2002), initially developed for (single-robot) CPP. STC operates on the terrain graph $G$ but finds a coverage path with minimal makespan on the decomposed graph $D$ derived from $G$ . The decomposed graph $D$ is also a 4-connected 2D grid graph, resulting from decomposing each vertex of $G$ into four decomposed vertices. Fig. 1 shows the terrain graph $G$ and its corresponding decomposed graph $D$ of an example terrain to be covered, where STC generates a single-robot coverage path on $D$ by circumnavigating (i.e., always moving along the right side of the spanning edges) the minimum spanning tree of $G$ .  \n\nLike STC, existing graph-based MCPP algorithms operate on the given terrain graph $G$ exclusively to build a tree cover\u2014a forest of multiple trees, each rooted at the initial vertex of a robot, that jointly cover all vertices of $G$ . The coverage path for each robot is then obtained by circumnavigating its corresponding tree. In essence, these algorithms reduce MCPP to the NP-hard Min-Max Rooted Tree Cover problem (Even et al. 2004; Nagamochi and Okada 2007) on $G$ that aims to optimize the weight of the largest-weighted tree in the tree cover since it determines the makespan of the resulting coverage paths on $D$ . However, operating on the terrain graph $G$ exclusively has two disadvantages. Firstly, it does not work for an incomplete terrain graph $G$ where some of the four decomposed vertices of a vertex might be blocked and thus absent in the decomposed graph $D$ . Secondly, an optimal tree cover on $G$ does not necessarily result in an optimal MCPP solution (as illustrated in Fig. 1-(c) and (d)), which yields an asymptotic suboptimality ratio of four for makespan in the worst case (Zheng et al. 2010), since circumnavigating the trees in a tree cover explores only a portion of the solution space that encompasses all possible sets of coverage paths on the decomposed graph $D$ .  \n\nTherefore, we take a different route to explore how to systematically search for good coverage paths directly on the decomposed graph. Our algorithmic contribution is through the following key aspects: (1) We propose a novel standalone algorithmic paradigm called Extended-STC (ESTC), an extension of STC, to address coverage planning problems on both complete and incomplete terrain graphs by directly operating on decomposed graphs. Importantly, we demonstrate that ESTC guarantees complete coverage for both singleand multi-robot settings, rendering it an efficient and versatile solution to coverage path planning. (2) We propose three types of specialized neighborhood operators to facilitate an effective local search process by identifying costefficient subgraphs of the decomposed graph that are used to generate coverage paths for the robots. The strategic integration of these operators enhances the efficiency of the local search in exploring the solution space. (3) We demonstrate how to combine these neighborhood operators with iterative calls to the ESTC paradigm to establish our proposed LS-MCPP framework for solving MCPP. To validate the effectiveness of LS-MCPP, we conduct extensive experiments, comparing it with three state-of-the-art baseline graph-based MCPP algorithms that operate on complete terrain graphs only. The results show that LS-MCPP achieves makespans that are smaller by up to $35.7\\\\%$ and $30.3\\\\%$ than two of the baseline algorithms, respectively, which compute suboptimal tree covers on the terrain graph. Additionally, LS-MCPP consistently achieves makespans comparable to or better than those achieved by the remaining baseline algorithm, which employs mixed integer programming (MIP) to compute optimal tree covers on the terrain graph. While the baseline algorithm takes more than tens of hours to complete, LS-MCPP accomplishes the same task in just a matter of minutes, showcasing its efficiency and practicality for large-scale real-world coverage problems.\u300d\n"]}}, "__type__": "1"}}, "template_store/metadata": {"e82448ff-6889-45db-9d37-4b94ad587706": {"template_hash": ""}}}