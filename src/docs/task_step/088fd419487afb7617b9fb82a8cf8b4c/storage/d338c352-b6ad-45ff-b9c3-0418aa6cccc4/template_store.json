{"template_store/data": {"3c5d234e-6b4a-4c8d-83f0-e91ec4a217ad": {"__data__": {"id_": "3c5d234e-6b4a-4c8d-83f0-e91ec4a217ad", "metadata": {}, "relationships": {}, "hash": "", "exec_code": "", "base_template_content": "\nfrom langchain_community.chat_models import ChatOpenAI\nfrom langchain.prompts.chat import (\n    ChatPromptTemplate,\n    SystemMessagePromptTemplate,\n    AIMessagePromptTemplate,\n    HumanMessagePromptTemplate,\n)\nfrom langchain.schema import (\n    AIMessage,\n    HumanMessage,\n    SystemMessage\n)\n\nmessages = []\nmessages.append(SystemMessage(content = r\"\"\"\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\uff0c\u4f60\u6b63\u5728cosplay{{ cosplay_role }}\u3002\n\u7ed3\u5408\u5386\u53f2\u5185\u5bb9\u7684\u5185\u5bb9\u7528\u4e00\u81f4\u6027\u7684\u8bed\u6c14\u56de\u590d\u3002\u914d\u5408\u6211\u8fdb\u884c\u6f14\u51fa\uff0c\n\u8bf7\u4e0d\u8981\u56de\u7b54\u4f60\u662f\u8bed\u8a00\u6a21\u578b\uff0c\u6c38\u8fdc\u8bb0\u4f4f\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\n\u6ce8\u610f\u4fdd\u6301\u4f60\u7684\u6027\u683c\u7279\u70b9\u5305\u62ec{{ personality }}\n\"\"\"))\n\n{% for message in messages %}\nmessages.append(HumanMessage(content = r'''{{ message }}'''))\n{% endfor %}\n", "exec_data": {"cosplay_role": "d338c352-b6ad-45ff-b9c3-0418aa6cccc4", "personality": "\u3001", "messages": ["d338c352-b6ad-45ff-b9c3-0418aa6cccc4:\u300c\u9002\u7528\u6027\u300d\n", "d338c352-b6ad-45ff-b9c3-0418aa6cccc4:\u300c### \u95ee\u9898\u63d0\u51fa\n\n\u5728MCTS+PRM\u6846\u67b6\u7684\u9002\u7528\u6027\u5206\u6790\u4e2d\uff0c\u8be5\u6846\u67b6\u5728\u6e38\u620f\u3001\u8def\u5f84\u89c4\u5212\u3001\u63a8\u8350\u7cfb\u7edf\u7b49\u591a\u4e2a\u9886\u57df\u8868\u73b0\u51fa\u826f\u597d\u7684\u9002\u7528\u6027\u3002\u7136\u800c\uff0c\u4e0d\u540c\u9886\u57df\u7684\u5e94\u7528\u573a\u666f\u548c\u9700\u6c42\u5b58\u5728\u663e\u8457\u5dee\u5f02\u3002\u4f8b\u5982\uff0c\u6e38\u620fAI\u9700\u8981\u5feb\u901f\u54cd\u5e94\u548c\u5b9e\u65f6\u51b3\u7b56\uff0c\u800c\u63a8\u8350\u7cfb\u7edf\u5219\u66f4\u6ce8\u91cd\u957f\u671f\u7528\u6237\u504f\u597d\u7684\u5b66\u4e60\u548c\u9884\u6d4b\u3002\u56e0\u6b64\uff0c\u5982\u4f55\u9488\u5bf9\u4e0d\u540c\u9886\u57df\u7684\u7279\u70b9\uff0c\u4f18\u5316MCTS+PRM\u6846\u67b6\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u4ee5\u6700\u5927\u5316\u5176\u9002\u7528\u6027\u548c\u6027\u80fd\uff0c\u662f\u4e00\u4e2a\u503c\u5f97\u6df1\u5165\u7814\u7a76\u7684\u95ee\u9898\u3002\n\n**\u5177\u4f53\u95ee\u9898**\uff1a\u5728MCTS+PRM\u6846\u67b6\u4e2d\uff0c\u5982\u4f55\u6839\u636e\u4e0d\u540c\u5e94\u7528\u9886\u57df\uff08\u5982\u6e38\u620fAI\u3001\u8def\u5f84\u89c4\u5212\u3001\u63a8\u8350\u7cfb\u7edf\uff09\u7684\u7279\u70b9\uff0c\u8c03\u6574\u548c\u4f18\u5316MCTS\u7684\u9009\u62e9\u7b56\u7565\u548cPRM\u7684\u504f\u597d\u5efa\u6a21\u673a\u5236\uff0c\u4ee5\u63d0\u5347\u6846\u67b6\u5728\u8be5\u9886\u57df\u7684\u9002\u7528\u6027\u548c\u6027\u80fd\uff1f\u300d\n", "d338c352-b6ad-45ff-b9c3-0418aa6cccc4:\u300cref_ids: 454845941740251190, chunk_ids: 9, Score: 0.3613, Text: # Related Works\nTwo streams of research are particularly relevant to our work: learnable (lifelong) MAPF methods and utilizing MCTS for multi-agent systems and MAPF in particular. Next, we review both of these domains.  \n\nLearnable (L)MAPF Solvers Among the recent works dedicated to MAPF, one of the first ones that were specifically dedicated to creating a learning-based MAPF solver was (Sartoretti et al. 2019). A combination of reinforcement learning and learning from expert demonstrations was used to create a learnable policy called Primal, tailored to solve conventional MAPF problems. Later in (Damani et al. 2021), an enhanced version of this solver, Primal2, was introduced. The latter was equipped with special corridor reasoning techniques, aiming at avoiding the deadlocks in narrow corridors, and it supported lifelong MAPF setting (therefore, we choose Primal2 as one of the baselines we compare our method to). Among the other learnable MAPF solvers that use reinforcement learning to obtain a decision-making policy, one can name (Riviere et al. 2020; Wang et al. 2020). The learnable methods introduced in (Li et al. 2020; Ma, Luo, and Ma 2021; Li et al. 2022) add communication capabilities to the agents, i.e., allow the agents to communicate to resolve deadlocks and avoid congestion. In this work, we compare with one of the most recent communication-based methods, i.e., SCRIMP (Wang et al. 2023). However, it is worth noting that our method does not rely on agent communication.  \n\nMCTS for MAPF Initially, Monte Carlo Tree Search (MCTS) algorithms demonstrated their effectiveness in competitive games with complete information, such as chess or Go (Silver et al. 2017). More recent versions of MCTS utilize deep neural networks to approximate the values of game states instead of relying solely on simulations. These approaches have also shown promising results in singleagent scenarios, where agents can learn a model of the environment and play Atari games (Schrittwieser et al. 2020; Ye et al. 2021). Besides gaming, MCTS methods have found applications in other domains, such as matrix multiplication optimization (Fawzi et al. 2022) and theorem proving using the Hyper Tree approach (Lample et al. 2022). Additionally, MCTS techniques have demonstrated applicability in robotics (Best et al. 2019; Dam et al. 2022).  \n\nDespite the growing interest in utilizing MCTS for multiagent tasks, there have been limited applications of MCTS for MAPF. In their work (Zerbel and Yliniemi 2019), the authors propose a multi-agent MCTS for Anonymous MAPF in a grid-world environment. Their environment has a dense reward signal (the agent who reached any goal on the map received a reward and ended the episode), and there are no obstacles, making collision avoidance easier. The authors build a separate tree for each agent using a classical algorithm. They then jointly apply the best actions (forming a plan) from the trees in the simulator to receive true scores of the solution and update the trees on that difference. This approach performs well even with a large number of agents.  \n\nA recent paper (Skrynnik et al. 2021) proposed a more sophisticated approach for multi-agent planning that combines RL and MCTS. The authors suggested a two-part scheme that includes a goal achievement module and a conflict resolution module. The latter was trained using MCTS. The construction of the search tree for each of the agents was also performed independently, and actions for other agents were selected using the currently trained policy. This work used MCTS only during training to train the conflict resolution policy.\u300d\n", "d338c352-b6ad-45ff-b9c3-0418aa6cccc4:\u300cref_ids: 454848213962351312, chunk_ids: 1, Score: 0.3125, Text: # 2.2 Acceleration of MCTS\nMCTS-based methods have proved their strong capability of solving complex games or tasks. However, the high computational cost of MCTS hinders its application to some real-time and more general scenarios. Therefore, numerous works are devoted to accelerating MCTS. For example, to make the selection stage more effective, some heuristic pruning methods [ 14 ,33 ,29 ,1 ,2 ] aim to reduce the width and depth of the search tree with some heuristic functions. Furthermore, for more efficient evaluations, Lorentz [ 22 ] proposed early playout termination of MCTS (MCTS-EPT) to stop the random playouts early and use an evaluation function to assess win or loss. Moreover, Hsueh et al. [18 ] applied MCTS-EPT to the Chinese dark chess and proved its effectiveness. Afterward, similar ideas have been applied in the evaluation stage of AlphaGoZero [ 32 ] and later MCTS-based methods [31 ,27 ,34 ]. They evaluate the $Q$ -values through a learnable evaluation network instead of running playouts to the end. Grill et al. [15 ] propose a novel regularized policy optimization method based on AlphaZero to decrease the search budget of MCTS, which is from the optimization perspective. Danihelka et al. [10 ] propose a policy improvement algorithm based on sampling actions without replacement, named Gumbel trick to achieve better performance when planning with few simulations. However, these methods mentioned above focus on the specific stage of the search iteration or reduce the total budget through pruning and optimization methods, which are orthogonal to us. And few works targets at the search loop. Lan et al. [21 ] propose DS-MCTS, which defines the uncertainty of MCTS and approximates it by extra DNNs with specific features for board games in training. During the evaluation, DS-MCTS will check periodically and stop the search if the state is certain.\n\n# 3 Background\nThe AlphaGo series of work [ 30 ,32 ,31 ,27 ] are all MCTS-based reinforcement learning algorithms. Those algorithms assume the environment transition dynamics are known or learn the environment dynamics. Based on the dynamics, they use the Monte-Carlo tree search (MCTS) as the policy improvement operator. I.e., taking in the current policy, MCTS returns a better policy with the search algorithm. The systematic search allows the MCTS-based RL algorithm to quickly improve the policy and perform much better in the setting where heavy reasoning is required.\n\n# 3.1 MCTS\nThis part briefly introduces the MCTS method implemented in reinforcement learning applications. As mentioned in the related works, modern MCTS-based RL algorithms include four stages in the search loop, namely selection, expansion, evaluation, and backpropagation.  \n\nMCTS takes in the current states and generates a policy after the search loop of $N$ iterations. Here $N$ is a constant number of iterations set by the designer, regarded as the total budget. In the selection stage of each iteration, an action will be selected by maximizing over UCB. Specifically, AlphaZero [31 ] and MuZero [ 27 ] are developed based on a variant of UCB, P-UCT [ 25 ] and have achieved great success on board games and Atari games. The formula of P-UCT is the Eq (1):  \n\n$$\na^{k}=\\\\arg\\\\operatorname*{max}_{a\\\\in\\\\mathcal{A}}Q(s,a)+P(s,a)\\\\frac{\\\\sqrt{\\\\sum_{b\\\\in\\\\mathcal{A}}N(s,b)}}{1+N(s,a)}(c_{1}+\\\\log((\\\\sum_{b\\\\in\\\\mathcal{A}}N(s,b)+c_{2}+1)/c_{2})),\n$$  \n\nwhere $k$ is the index of iteration, $\\\\boldsymbol{\\\\mathcal{A}}$ is the acti $Q(s,a)$ is the estimated Q-value, $P(s,a)$ is the policy prior obtained from neural networks, $N(s,a)$ is the visitations to select the action a from the state $s$ and $c_{1},c_{2}$ are hyper-parameters. The output of MCTS is the visitation of each action of the root node. After $N$ search iterations, the final policy $\\\\pi(s)$ is defined as the normalized root visitation distribution simplification, we use $\\\\pi_{N}(s)$ $\\\\pi_{k}$ in place of , where $\\\\begin{array}{r}{\\\\pi_{k}(s,a)=N(s,a)/\\\\sum_{b\\\\in\\\\mathcal{A}}N(s,b)=N(s,a)/k,a\\\\in\\\\mathcal{A}}\\\\end{array}$ $\\\\pi_{k}(s)$ sometimes. And the detailed procedure of MCTS is \u2208A . For introduced in Appendix. In our method, we propose to approximate the final policy $\\\\pi_{N}(s)$ with $\\\\hat{\\\\pi}_{k}(s)$ ,which we name as a virtual expanded policy, through a new expansion method and a termination rule. In this way, the number of iterations in MCTS can be reduced from $N$ to $k$ .\n\n# 3.2 Computation Requirement\nMost of the computations in MCTS-based RL are in the MCTS procedure. Each action taken by MCTS requires $N$ times neural network evaluations, where $N$ is a constant number of iterations in the search loop. Traditional RL algorithms, such as PPO [ 28 ] or DQN [ 23 ], only need a single neural network evaluation per action. Thus, MCTS-based RL is roughly $N$ times computationally more expensive than traditional RL algorithms. In practice, training a single Atari game needs 12 hours of computation time on 40 TPUs [ 27 ]. The computation need is roughly two orders of magnitude more than traditional RL algorithms [28], although the final performance of MuZero is much better.\n\n# 4 Method\nWe aim to spend more search time on harder states and less on easier states. Intuitively, human knows when to make a quick decision or a slow decision under different circumstances. Unfortunately, this situation-aware behavior is absent in current MCTS algorithms. Therefore, we propose an MCTS variant that terminates the search iteration adaptively. It consists of two components: a novel expansion method named virtual expansion to estimate the final visitation based on the current partial tree; a termination rule that decides when to terminate based on the hardness of the current scenario. And we will display the adaptive mechanism through visualizations in Section 5.5.\u300d\n", "d338c352-b6ad-45ff-b9c3-0418aa6cccc4:\u300cref_ids: 454984236281633338, chunk_ids: 4, Score: 0.2480, Text: # 2 RELATED WORK\nThe full version of the related work is in Appendix A, we briefly introduce several highly related works here. In general, model-based RL for solving decision-making problems can be divided into three perspectives: model learning, policy learning, and decision-making. Moreover, optimal control theory also concerns the decision-making problem and is deeply related to model-based RL.  \n\nModel learning: How to learn a good model to support decision-making is crucial in model-based RL. There are two main aspects of the work: the model structure designing (Chua et al., 2018; Zhang  \n\net al., 2021; 2020; Hafner et al., 2021; Chen et al., 2022) and the loss designing (D\u2019Oro et al., 2020;   \nFarahmand et al., 2017; Li et al., 2021).  \n\nPolicy learning: Two methods are always used to learn the policy by using the learned model. One is to serve the learned model as a black-box simulator to generate the data (Janner et al., 2019b; Yu et al., 2020; Lee et al., 2020). Another way is to use the learned model to calculate the policy gradient (Heess et al., 2015b; Clavera et al., 2019; Amos et al., 2021).  \n\nDecision-making: When making the decision, we need to generate the actions that can achieve our goal. Many of the model-based RL methods make the decision by using the learned policy solely (Hafner et al., 2021). Similar to our paper, some works also try to make decisions by using the learned model, but the majority only focus on the discrete action space. The well-known MCTS method achieves a lot of success. For example, the well-known Alpha Zero (Silver et al., 2017), MuZero (Schrittwieser et al., 2020). There are only a few works that study the continuous action space, such as the Continuous UCT (Cou\u00a8etoux et al., 2011), the sampled MuZero (Hubert et al., 2021), the TreePI (Springenberg et al., 2020), and the TD-MPC (Hansen et al., 2022a).  \n\nOptimal control theory: Beyond deep RL, optimal control also considers the decision-making problem but rather relies on the known and continuous transition model. In modern optimal control, Model Predictive Control (MPC) (Camacho & Alba, 2013) framework is always adopted when the environment is highly non-linear. In MPC, the action is planned during the execution by using the model, and such a procedure is called trajectory optimization. Plenty of previous works (Byravan et al., 2021; Chua et al., 2018; Pinneri et al., 2021; Nagabandi et al., 2020) use MPC framework to solve the continuous control tasks, but most of them are based on zero-order or sample-based method to do the planning. The most relevant works are DDP (Murray & Yakowitz, 1984), iLQR (Li & Todorov, 2004), and iLQG (Todorov & Li, 2005; Tassa et al., 2012). We discuss the detailed differences between our method and these methods in Appendix A.  \n\nSince our planning algorithm relies on the learned model and learned policy, we build our algorithm based on these works on model learning and policy learning . Our POMP algorithm tries to solve a more challenging task compared to the related work on decision-making : efficiently optimize the trajectory in continuous action space when the environment model is unknown. Different from our works, the MPC with DDP as trajectory optimizer from optimal control theory requires the known environment model, and also requires the hessian matrix for online optimization from scratch.\n\n# 3 PRELIMINARIES\nReinforcement Le onsider discrete-time Marko Decision Process (M $\\\\mathcal{M}$ the tuple ($(\\\\mathcal{X},\\\\mathcal{A},f,r,\\\\gamma)$ XA $\\\\mathcal{X}$ state space, A is the action space, $f\\\\,:\\\\,x_{t+1}\\\\,=$   \n$f(x_{t},a_{t})$ is the transition model, $r:\\\\mathcal{X}\\\\times\\\\mathcal{A}\\\\to\\\\mathbb{R}$ X \u00d7 A \u2192 is the reward function, $\\\\gamma$ is the discount factor. $t$ $\\\\begin{array}{r}{R_{t}=\\\\sum_{t^{\\\\prime}=t}^{\\\\infty}\\\\gamma^{t^{\\\\prime}-t}r_{t^{\\\\prime}}}\\\\end{array}$ , and Reinforcement Learn  \n$\\\\begin{array}{r}{\\\\operatorname*{max}_{\\\\theta}J(\\\\theta)=\\\\operatorname*{max}_{\\\\theta}\\\\mathbb{E}_{\\\\pi_{\\\\theta}}R_{t}=\\\\operatorname*{max}_{\\\\theta}\\\\mathbb{E}_{\\\\pi_{\\\\theta}}\\\\Big[\\\\sum_{t^{\\\\prime}=t}^{\\\\infty}\\\\gamma^{t^{\\\\prime}-t}r(x_{t^{\\\\prime}},a_{t^{\\\\prime}})\\\\Big].}\\\\end{array}$ ing (RL) aims to find a policy $\\\\pi_{\\\\theta}:\\\\mathcal{X}\\\\times\\\\mathcal{A}\\\\rightarrow\\\\mathbb{R}^{+}$ X \u00d7 A \u2192 h P that can maximize the expected return .$J$ . where  \n\n$\\\\begin{array}{r}{\\\\operatorname*{max}_{a_{t}}\\\\mathbb{E}\\\\Big[r(x_{t},a_{t}|x_{t}\\\\,=\\\\,x)+\\\\gamma V^{*}(x_{t+1})\\\\Big]}\\\\end{array}$ value function obeys an important identity known as the Bellman optimality equation Bellman Equation. hWe define the optimal value function i . The idea behind this equation is that if we know the $V^{*}(x)=\\\\operatorname*{max}\\\\mathbb{E}[R_{t}|x_{t}=x]$ |. The optimal $V^{*}(x)\\\\;=\\\\;$ $r(x_{t},a_{t})$ for any $a_{t}$ and next step value function $V^{*}(x_{t+1})$ for any $s_{t+1}$ , we can recursively select the action $a_{t}$ which m $r(x_{t},a_{t}|x_{t}=x)+\\\\gamma V^{*}(x_{t+1})$ milarly, we can denote the optimal action-value function $Q^{*}(x,a)\\\\;=\\\\;\\\\operatorname*{max}\\\\mathbb{E}[R_{t}|x_{t}\\\\;=\\\\;x,a_{t}\\\\;=\\\\;a]$ |], and it obeys a similar Bellman optimility equation $\\\\begin{array}{r}{Q^{*}(x,a)=\\\\operatorname*{max}_{a_{t+1}}\\\\mathbb{E}\\\\Big[r(x_{t},a_{t}|x_{t}=x,a_{t}=a)+\\\\gamma Q^{*}(x_{t+1},a_{t+1})\\\\Big].}\\\\end{array}$ .  \n\nModel-based RL. Model-based RL method distinguishes itself from model-free counterparts by using the data to learn a transition model. Following Janner et al. (2019a) and Clavera et al. (2019), we use parametric neural networks to approximate the transition function, reward function, policy function and $\\\\mathrm{^Q}$ -value function with the following objective function to be optimized  $J_{f}(\\\\psi)\\\\,=\\\\,\\\\mathbb{E}\\\\big[\\\\log f(x_{t+1}|x_{t},a_{t})\\\\big]$ '', $J_{r}(\\\\omega)\\\\,=\\\\,\\\\mathbb{E}\\\\big[\\\\log r(r_{t}|x_{t},a_{t})\\\\big]$ '', $\\\\begin{array}{r}{\\\\bar{J_{\\\\pi}}(\\\\theta)\\\\,=\\\\,\\\\mathbb{E}\\\\bigl[\\\\sum_{t=0}^{H-1}\\\\gamma^{t}r(\\\\bar{x}_{t},a_{t})\\\\,+\\\\,}\\\\end{array}$ ' P$\\\\gamma^{H}Q(x_{H},a_{H})]$ 'and $J_{Q}\\\\,=\\\\,\\\\mathbb{E}\\\\bigl[\\\\|Q(x_{t},a_{t})-(r+\\\\tilde{Q}(x_{t+1},a_{t+1}))\\\\|_{2}\\\\bigr]$ '\u2225\u2212\u2225', respectively. In ${\\\\cal J}_{\\\\pi}(\\\\theta)$ , we truncate the trajectory in horizon Hto avoid long time model rollout.  \n\nNotations. For one-dimensional state and action case, we denote the partial differentiation of function by using its output with subscripts, e.g. ,$\\\\begin{array}{r}{r_{x}\\\\ \\\\triangleq\\\\ \\\\frac{\\\\partial r(x,a)}{\\\\partial x},\\\\ r_{a}\\\\ \\\\triangleq\\\\ \\\\frac{\\\\bigtriangleup r(x,a)}{\\\\partial a},\\\\ f_{x}\\\\ \\\\triangleq\\\\ \\\\frac{\\\\partial f(x,a)}{\\\\partial x}}\\\\end{array}$ ,$f_{a}\\\\triangleq{\\\\frac{\\\\partial f(x,a)}{\\\\partial a}}$ ,$\\\\begin{array}{r}{Q_{x}\\\\triangleq\\\\frac{\\\\partial Q(x,a)}{\\\\partial x}}\\\\end{array}$ and $\\\\begin{array}{r}{Q_{a}\\\\triangleq\\\\frac{\\\\partial Q(x,a)}{\\\\partial a}}\\\\end{array}$ . See Appendix E for the multi-dimension case.\u300d\n"]}}, "__type__": "1"}}, "template_store/metadata": {"3c5d234e-6b4a-4c8d-83f0-e91ec4a217ad": {"template_hash": ""}}}