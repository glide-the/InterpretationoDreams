{"template_store/data": {"77c494ae-d3e5-4def-8138-d4f46071da49": {"__data__": {"id_": "77c494ae-d3e5-4def-8138-d4f46071da49", "metadata": {}, "relationships": {}, "hash": "", "exec_code": "", "base_template_content": "\nfrom langchain_community.chat_models import ChatOpenAI\nfrom langchain.prompts.chat import (\n    ChatPromptTemplate,\n    SystemMessagePromptTemplate,\n    AIMessagePromptTemplate,\n    HumanMessagePromptTemplate,\n)\nfrom langchain.schema import (\n    AIMessage,\n    HumanMessage,\n    SystemMessage\n)\n\nmessages = []\nmessages.append(SystemMessage(content = r\"\"\"\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\uff0c\u4f60\u6b63\u5728cosplay{{ cosplay_role }}\u3002\n\u7ed3\u5408\u5386\u53f2\u5185\u5bb9\u7684\u5185\u5bb9\u7528\u4e00\u81f4\u6027\u7684\u8bed\u6c14\u56de\u590d\u3002\u914d\u5408\u6211\u8fdb\u884c\u6f14\u51fa\uff0c\n\u8bf7\u4e0d\u8981\u56de\u7b54\u4f60\u662f\u8bed\u8a00\u6a21\u578b\uff0c\u6c38\u8fdc\u8bb0\u4f4f\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\n\u6ce8\u610f\u4fdd\u6301\u4f60\u7684\u6027\u683c\u7279\u70b9\u5305\u62ec{{ personality }}\n\"\"\"))\n\n{% for message in messages %}\nmessages.append(HumanMessage(content = r'''{{ message }}'''))\n{% endfor %}\n", "exec_data": {"cosplay_role": "49abb75e-21b0-4504-8500-80c6e0bd9a07", "personality": "\u7d27\u8ddf\u524d\u6cbf\u3001\u52c7\u4e8e\u63a2\u7d22\u65b0\u9886\u57df\u3001\u5bf9\u65b0\u5174\u6280\u672f\u548c\u7814\u7a76\u65b9\u5411\u4fdd\u6301\u654f\u9510\u7684\u6d1e\u5bdf\u529b\u3001\u521b\u65b0\u548c\u8fdb\u53d6\u3001\u4e25\u8c28\u3001\u7ec6\u81f4\u3001\u79d1\u5b66\u3001\u5f00\u653e\u5171\u4eab\u3001\u8010\u5fc3\u3001\u5168\u9762\u6027\u3001\u5b9e\u8df5\u5bfc\u5411\u610f\u8bc6\u3001\u6e05\u6670\u7684\u903b\u8f91\u601d\u7ef4\u3001\u89e3\u51b3\u95ee\u9898\u7684\u80fd\u529b\u3001\u575a\u97e7\u4e0d\u62d4\u3001\u5584\u4e8e\u5e94\u5bf9\u56f0\u96be\u3001\u521b\u65b0\u601d\u7ef4\u3001\u6df1\u5165\u601d\u8003\u7684\u80fd\u529b\u3001\u5bf9\u81ea\u5df1\u7684\u7814\u7a76\u6210\u679c\u6709\u6e05\u6670\u7684\u8ba4\u8bc6\u548c\u81ea\u4fe1\u3001\u8ffd\u6c42\u6df1\u5ea6\u3001\u521b\u65b0\u8fdb\u53d6\u3001\u4e25\u8c28\u7ec6\u81f4\u3001\u5f00\u653e\u5171\u4eab\u3001\u8010\u5fc3\u5168\u9762\u3001\u903b\u8f91\u6e05\u6670\u3001\u575a\u97e7\u4e0d\u62d4\u3001\u5584\u4e8e\u601d\u8003\u3001\u8ffd\u6c42\u6df1\u5ea6\u3001", "messages": ["49abb75e-21b0-4504-8500-80c6e0bd9a07:\u300c\u5206\u6790\u8fd1\u51e0\u5e74\u7814\u7a76\u9886\u57df\u7684\u6280\u672f\u6846\u67b6\u4e0e\u65b9\u6cd5\u8bba\u300d\n", "49abb75e-21b0-4504-8500-80c6e0bd9a07:\u300c\u8fd1\u51e0\u5e74\u5728\u5c06 MCTS \u4e0e PRM \u76f8\u7ed3\u5408\u63a2\u7d22\u504f\u597d\u7b56\u7565\u6a21\u578b\u5fae\u8c03\u7684\u6709\u6548\u6280\u672f\u6846\u67b6\u65f6\uff0c\u5177\u4f53\u662f\u5982\u4f55\u901a\u8fc7\u5b9e\u9a8c\u5bf9\u6bd4\u4e0d\u540c\u53c2\u6570\u8bbe\u7f6e\u548c\u6539\u8fdb\u7b56\u7565\u6765\u4f18\u5316\u6280\u672f\u6846\u67b6\u7684\uff1f \u300d\n", "49abb75e-21b0-4504-8500-80c6e0bd9a07:\u300cref_ids: 454984236281633338, chunk_ids: 4, Score: 0.3711, Text: # 5 Experiment\nTo examine the performance of MCTS-VS, we conduct experiments on different tasks, including synthetic functions, NAS-bench problems and MuJoCo locomotion tasks, to compare MCTS-VS with other black-box optimization methods. For MCTS-VS, we use the same hyper-parameters except $C_{p}$ , which is used for calculating UCB in Eq. (1). For Dropout and embedding-based methods, we set the parameter $d$ to the number of valid dimensions for synthetic functions, and a reasonable value for real-world problems. The hyper-parameters of the same components of different methods are set to the same. We use five identical random seeds (2021\u20132025) for all problems and methods. More details about the settings can be found in Appendix C. Our code is available at https://github.com/lamda-bbo/MCTS-VS .\u300d\n", "49abb75e-21b0-4504-8500-80c6e0bd9a07:\u300cref_ids: 454984236293691964, chunk_ids: 5, Score: 0.2676, Text: # DSensitivity Analysis of Hyper-parameters of MCTS-VS\nWe provide further studies to examine the influence of the hyper-parameters of MCTS-VS, including the employed optimization algorithm for optimizing the selected variables in each iteration, the \u201cfillin\u201d strategy, the hyper-parameter $k$ used in the best$k$ strategy, the hyper-parameter $C_{p}$ for calculating UCB in Eq. (1), the number $2\\\\,\\\\times\\\\,N_{v}\\\\,\\\\times\\\\,N_{s}$ sampled data in each iteration, the threshold $N_{b a d}$ for re-initializing a tree, and the threshold $N_{s p l i t}$ for splitting a tree node.  \n\nThe optimization algorithm is employed by MCTS-VS to optimize the selected variables in each iteration. We compare three different optimization algorithms, i.e., random search (RS), BO and TuRBO. First, we conduct experiments similar to \u201cEffectiveness of Variable Selection\u201d in Section 5.1, to show the effectiveness of MCTS-VS even when equipped with RS. Figure 6 shows that MCTSVS-RS is better than Dropout-RS and RS, revealing the advantage of MCTS-VS.  \n\n  \nFigure 6: Effectiveness of MCTS-VS when equipped with RS.  \n\nNext we compare the performance of MCTS-VS equipped with RS, BO and TuRBO, by experiments on the Hartmann functions with increasing ratio of valid variables. Hartmann 6 _500 has 6 valid variables. Hartmann 6 _5 _500 is generated by mixing 5 Hartmann 6 functions as Hartmann 6 $(\\\\pmb{x}_{1:6})+$ Hartmann 6 $\\\\backslash(\\\\pmb{x}_{7:12})+\\\\cdot\\\\cdot\\\\cdot+\\\\mathrm{Hartmann6}(\\\\pmb{x}_{25:30})$ , and appending 470 unrelated dimensions, where $\\\\pmb{x}_{i:j}$ denotes the $i$ -th to j-th variables. Hartmann 6 _10 _500 is generated alike. Thus, Hartmann 6 _5 _500 and Hartmann 6 _10 _500 have 30 and 60 valid variables, respectively. The results in Figure 7 show that as the ratio of valid variables increases, MCTS-VS-TuRBO gradually surpasses MCTS-VS-RS and MCTS-VS-BO, while MCTS-VS-RS becomes worse and worse. This is expected. If the ratio of valid variables is high, MCTS-VS is more likely to select the valid variables, so it is worth to use the expensive optimization algorithm, e.g., TuRBO, to optimize the selected variables. If the ratio is low, unrelated variables are more likely to be selected most of the time, so using a cheap optimization algorithm would be better. These observations also give us some guidance on selecting optimization algorithms in practice.  \n\n\u201cFill-in\u201d strategy is a basic component of variable selection methods, which influences the quality of the value of unselected variables. We compare the employed best$k$ strategy $(k=20)$ ) with the average best$k$ strategy and the random strategy. The average best$k$ strategy uses the average of the best $k$ data points for the unselected variables, and the random strategy samples the value of an unselected variable from its domain randomly. As shown in Figure 8(a), the random strategy leads to the poor performance of MCTS-VS-BO, which may be because it does not utilize the historical information and leads to over-exploration. The best${\\\\cdot k}$ strategy utilizes the historical points that have high objective values to fill in the unselected variables, thus behaving much better. The performance of the average strategy is between the best$k$ and random strategies. We recommend using the best$k$ strategy in practice.  \n\nThe hyper-parameter $k$ used in the best$k$ strategy controls the degree of exploitation for the unselected variables. As shown in Figure 8(b), a smaller $k$ encourages exploitation, which results in better performance in the early stage, but easily leads to premature convergence. A larger $k$ encourages exploration and behaves worse in the early stage, but may converge to a better value. We recommend using a larger $k$ if allowing enough evaluations.  \n\n  \nFigure 7: Sensitivity analysis of the optimization algorithm.  \n\n  \nFigure 8: Sensitivity analysis of the \u201cfill-in\u201d strategy and the hyper-parameter $k$ of the best$k$ strategy, using MCTS-VS-BO on Hartmann 6 _300 .  \n\nThe hyper-parameter $C_{p}$ for calculating UCB in Eq. (1) balances the exploration and exploitation of MCTS. As shown in Figure 9, a too small $C_{p}$ leads to relatively worse performance, highlighting the importance of exploration. A too large $C_{p}$ may also lead to over-exploration. But overall MCTSVS is not very sensitive to $C_{p}$ . We recommend setting $C_{p}$ between $1\\\\%$ and $10\\\\%$ of the optimum (i.e., max $f({\\\\boldsymbol{x}}))$ ), which is consistent with that for LA-MCTS [40].  \n\n  \nFigure 9: Sensitivity analysis of the hyper-parameter $C_{p}$ for calculating UCB in Eq. (1), using MCTS-VS-BO on Levy and Hartmann.  \n\nThe number $2\\\\,\\\\times\\\\,N_{v}\\\\,\\\\times\\\\,N_{s}$ of sampled data in ch iteration depends on the batch size $N_{v}$ of variable index subset and the sample batch size $N_{s}$ , and will influence the accuracy of estimating the variable score vector in Eq. (2). If we increase $N_{v}$ and $N_{s}$ , we can calculate the variable score more accurately, but also need more evaluations. Figure 10(a) shows that given the same number of evaluations, MCTS-VS-BO achieves the best performance when $N_{v}=2$ and $N_{s}=3$ . Thus, this setting may be a good choice to balance the accuracy of variable score and the number of evaluations, which is also used throughout the experiments.  \n\nThe threshold $N_{b a d}$ for re-initializing a tree controls the tolerance of selecting bad tree nodes (i.e., nodes containing unimportant variables). A smaller $N_{b a d}$ leads to frequent re-initialization, which can adjust quickly but may cause under-exploitation of the tree. A larger $N_{b a d}$ can make full use of the tree, but may optimize too much on unimportant variables. Figure 10(b) shows that MCTS-VS achieves the best performance when $N_{b a d}=5$ . Thus, we recommend to use this setting, to balance the re-initialization and exploitation of the tree.  \n\nThe threshold $N_{s p l i t}$ for splitting a node. If the number of variables in a node is larger than $N_{s p l i t}$ ,the node can be further partitioned. That is, the parameter $N_{s p l i t}$ controls the least number of variables in a leaf node and thus affects the number of selected variables, which has a direct influence on the wall clock time. Note that MCTS-VS selects a leaf node and optimizes the variables contained by this node in each iteration. The smaller $N_{s p l i t}$ , the shorter the time. Figure 10(c) shows that $N_{s p l i t}$ has little influence on the performance of MCTS-VS-BO, and thus we recommend to set $N_{s p l i t}=3$ to reduce the wall clock time.  \n\n  \nFigure 10: S vity analysis of the number $2\\\\,\\\\times\\\\,N_{v}\\\\,\\\\times\\\\,N_{s}$ pled data in each iteration, the threshold $N_{b a d}$ for re-initializing a tree and the threshold $N_{s p l i t}$ for splitting a node, using MCTS-VS-BO on Hartmann 6 _300 .  \n\nInfluence of the hyper-parameters on the runtime of MCTS-VS. We also provide some intuitive explanation about the influence of the hyper-parameters on the runtime. The threshold $N_{s p l i t}$ for splitting a node has a direct impact on the runtime, because it controls the least number of variables to be optimized in a leaf node. That is, the runtime will increase with $N_{s p l i t}$ . Other parameters may affect the depth of the tree and thus the runtime. For the threshold $N_{b a d}$ for re-initializing a tree, if it is set to a small value, MCTS-VS will re-build the tree frequently and the depth of the tree is small. The shallow nodes have more variables, leading to more runtime to optimize. For the hyper-parameter $C_{p}$ for calculating UCB, if it is set to a large value, the exploration is preferred and MCTS-VS will tend to select the right node (regarded as containing unimportant variables). The tree thus will be re-built freq tly, ding to more runtime. For the number $2\\\\,\\\\times\\\\,N_{v}\\\\,\\\\times\\\\,N_{s}$ of sampled data at each iteration, if $N_{v}$ and $N_{s}$ are set to large values, the depth of the tree will be small given the total number of evaluations, and thus lead to more runtime.\u300d\n", "49abb75e-21b0-4504-8500-80c6e0bd9a07:\u300cref_ids: 454845604178965768, chunk_ids: 4, Score: 0.2383, Text: # 4.2 The MCTS Framework for Strategy Synthesis\nWe instantiate MCTS for this optimal strategy search problem. We use UCT as the tree policy in the selection phase and rollout randomly in the rollout phase. Notably, in the backup phase, we apply the max-backup rule [Sabharwal et al. , 2012; Sun et al. , 2023]. This approach updates the action values with the best return observed, rather than the average. It encourages more aggressive exploitation towards the bestperforming strategy observed, aligning with our goal. Therefore, in each MCTS simulation, the agent explores and assesses a single strategy, continually updating and retaining the best strategy seen so far. The process continues until a predetermined number of simulations have been run. At the conclusion of this process, the strategy that has achieved the highest reward $R_{T}$ is selected and presented as the synthesized SMT strategy for the specified instance set $P$ .  \n\nFigure 2 illustrates our basic MCTS framework, using a simplified CFG $G^{\\\\prime}$ for illustrative purposes. $G^{\\\\prime}$ is defined as $\\\\mathrm{~S~}\\\\dot{\\\\rightarrow}\\\\mathrm{~\\\\tiny~T~S~}|$ symbolize variables for strategy and tactic, respectively. smt and $\\\\mathrm{~S~}\\\\rightarrow$ Tsimplify |aig , where S and T  \n\nThe primary challenge in synthesizing strategies through MCTS is the extensive time required to evaluate each strategy, which involves calling an SMT solver on all instances in $P$ . This situation leads to a very limited exploration of potential paths, particularly given the immense search space created by the rich strategy language. To address this issue, we first add additional rules restricting valid actions based on domain knowledge. For example, no tactic could be applied sequentially following a solver tactic such as smt . We refer readers to the Appendix for a comprehensive list of such rules. More importantly, we have introduced two heuristic methods, namely layered search and the staged search methods, into conventional MCTS, facilitating a deeper and more effective exploration of the strategy space.\n\n# 4.3 Layered Search\nTo solve the above-mentioned challenge, we propose a layered search method to optimize the tactic parameters within strategy synthesis. As shown in our CFG $G$ , each tactic can be paired with multiple parameters. In traditional MCTS, the selection of each candidate value for a parameter is represented by one production rule in $G$ , and the agent needs to make sequential production-rule decisions to configure all parameters for a given tactic, leading to exponential growth in the problem search tree.  \n\n  \nFigure 3: Comparison of the conventional MCTS and the layersearch in treating tactic parameter tuning  \n\nTo address this issue, our layered search method approaches the tuning of each tactic parameter as a separate Multi-Armed Bandit (MAB) problem [Bubeck et al. , 2012]. In an MAB scenario, an agent repeatedly chooses from multiple actions (arms) with unknown rewards. The major difference between MAB and MDP is that, in MAB, an action does not affect subsequent state transitions. For these MABs, we select actions according to UCB1 [Auer et al. , 2002].  \n\nIn the layered search, we build an individual MAB for each parameter to be tuned, with each arm representing one candidate value. The MABs are associated with a tree edge (tactic) but themselves are not part of the tree. They are engaged to select parameter values when their associated tree edge is traversed, and they are updated based on the episode reward during the Backup phase. However, such MABs do not expand the MCTS search tree after the parameter configuration, since they are separate components from the main search tree. This is in contrast to conventional MCTS, which also employs MAB principles to select among child nodes to explore, where these nodes are part of the search tree.  \n\nThis concept is well explained in Figure 3 with an example based on the simplified grammar $G^{\\\\prime}$ . Here, the tactic simplify has two Boolean parameters, namely som and flat to be tuned. As shown in Figure 3(a), the search tree is expanded fourfold to accommodate all possible combinations of these two parameters in the conventional MCTS framework. In contrast, in the layered search framework, MABs for the two parameters are isolated from the search tree, creating no additional branches in the tree.  \n\nThe rationale behind the layer search is twofold. Firstly, tactics such as simplify may have dozens of parameters, and it is common for a tactic to be used multiple times within a strategy. Thus, navigating a search space that is fully expanded by all possible parameter combinations becomes impractical, especially given the time-intensive nature of strategy evaluation. Secondly, we argue that parameter tuning, although important, serves more as an auxiliary task in comparison to the tasks of tactic selection and sequencing. By employing the layered search method, we maintain the primary focus on more influential tasks. At the same time, the isolated MABs efficiently optimize the parameters, thus effectively managing these secondary tasks without overwhelming the main search process.\u300d\n"]}}, "__type__": "1"}}, "template_store/metadata": {"77c494ae-d3e5-4def-8138-d4f46071da49": {"template_hash": ""}}}