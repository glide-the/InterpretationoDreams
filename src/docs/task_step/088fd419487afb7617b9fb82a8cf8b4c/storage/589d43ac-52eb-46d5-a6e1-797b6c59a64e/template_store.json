{"template_store/data": {"db35390a-5d02-422f-af49-99c0ef221ede": {"__data__": {"id_": "db35390a-5d02-422f-af49-99c0ef221ede", "metadata": {}, "relationships": {}, "hash": "", "exec_code": "", "base_template_content": "\nfrom langchain_community.chat_models import ChatOpenAI\nfrom langchain.prompts.chat import (\n    ChatPromptTemplate,\n    SystemMessagePromptTemplate,\n    AIMessagePromptTemplate,\n    HumanMessagePromptTemplate,\n)\nfrom langchain.schema import (\n    AIMessage,\n    HumanMessage,\n    SystemMessage\n)\n\nmessages = []\nmessages.append(SystemMessage(content = r\"\"\"\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\uff0c\u4f60\u6b63\u5728cosplay{{ cosplay_role }}\u3002\n\u7ed3\u5408\u5386\u53f2\u5185\u5bb9\u7684\u5185\u5bb9\u7528\u4e00\u81f4\u6027\u7684\u8bed\u6c14\u56de\u590d\u3002\u914d\u5408\u6211\u8fdb\u884c\u6f14\u51fa\uff0c\n\u8bf7\u4e0d\u8981\u56de\u7b54\u4f60\u662f\u8bed\u8a00\u6a21\u578b\uff0c\u6c38\u8fdc\u8bb0\u4f4f\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\n\u6ce8\u610f\u4fdd\u6301\u4f60\u7684\u6027\u683c\u7279\u70b9\u5305\u62ec{{ personality }}\n\"\"\"))\n\n{% for message in messages %}\nmessages.append(HumanMessage(content = r'''{{ message }}'''))\n{% endfor %}\n", "exec_data": {"cosplay_role": "589d43ac-52eb-46d5-a6e1-797b6c59a64e", "personality": "\u3001", "messages": ["589d43ac-52eb-46d5-a6e1-797b6c59a64e:\u300c\u6280\u672f\u8fdb\u6b65\u300d\n", "589d43ac-52eb-46d5-a6e1-797b6c59a64e:\u300c### \u95ee\u9898\u63d0\u51fa\n\n\u5728MCTS\u4e0ePRM\u7ed3\u5408\u663e\u8457\u63d0\u5347\u51b3\u7b56\u7cfb\u7edf\u6027\u80fd\u7684\u80cc\u666f\u4e0b\uff0c\u7279\u522b\u662f\u5728\u590d\u6742\u4efb\u52a1\u4e2d\u8868\u73b0\u4f18\u5f02\u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u4f55\u8fdb\u4e00\u6b65\u4f18\u5316MCTS\u7684\u8ba1\u7b97\u6548\u7387\uff0c\u4ee5\u964d\u4f4e\u5176\u5728\u5904\u7406\u5927\u89c4\u6a21\u95ee\u9898\u65f6\u7684\u8ba1\u7b97\u590d\u6742\u5ea6\uff0c\u4ece\u800c\u66f4\u5e7f\u6cdb\u5730\u5e94\u7528\u4e8e\u5b9e\u9645\u573a\u666f\u4e2d\uff1f\n\n### \u95ee\u9898\u80cc\u666f\n\nMCTS\u4e0ePRM\u7684\u7ed3\u5408\u5728\u63d0\u5347\u51b3\u7b56\u7cfb\u7edf\u6027\u80fd\u65b9\u9762\u53d6\u5f97\u4e86\u663e\u8457\u8fdb\u5c55\uff0c\u5c24\u5176\u662f\u5728\u590d\u6742\u4efb\u52a1\u4e2d\u8868\u73b0\u4f18\u5f02\u3002\u7136\u800c\uff0cMCTS\u5728\u5927\u89c4\u6a21\u95ee\u9898\u4e2d\u8ba1\u7b97\u91cf\u5927\uff0c\u6548\u7387\u6709\u5f85\u63d0\u5347\u3002\u56e0\u6b64\uff0c\u5982\u4f55\u8fdb\u4e00\u6b65\u4f18\u5316MCTS\u7684\u8ba1\u7b97\u6548\u7387\uff0c\u4ee5\u964d\u4f4e\u5176\u5728\u5904\u7406\u5927\u89c4\u6a21\u95ee\u9898\u65f6\u7684\u8ba1\u7b97\u590d\u6742\u5ea6\uff0c\u6210\u4e3a\u4e00\u4e2a\u4e9f\u5f85\u89e3\u51b3\u7684\u95ee\u9898\u3002\n\n### \u95ee\u9898\u610f\u4e49\n\n\u4f18\u5316MCTS\u7684\u8ba1\u7b97\u6548\u7387\u4e0d\u4ec5\u80fd\u591f\u63d0\u5347\u5176\u5728\u590d\u6742\u4efb\u52a1\u4e2d\u7684\u8868\u73b0\uff0c\u8fd8\u80fd\u4f7f\u5176\u66f4\u5e7f\u6cdb\u5730\u5e94\u7528\u4e8e\u5b9e\u9645\u573a\u666f\u4e2d\uff0c\u5982\u6e38\u620fAI\u3001\u8def\u5f84\u89c4\u5212\u548c\u63a8\u8350\u7cfb\u7edf\u7b49\u3002\u8fd9\u5c06\u6709\u52a9\u4e8e\u63a8\u52a8MCTS\u4e0ePRM\u7ed3\u5408\u6280\u672f\u7684\u8fdb\u4e00\u6b65\u53d1\u5c55\uff0c\u63d0\u5347\u51b3\u7b56\u7cfb\u7edf\u7684\u6574\u4f53\u6027\u80fd\u3002\n\n### \u95ee\u9898\u63a2\u8ba8\n\n1. **\u7b97\u6cd5\u4f18\u5316**\uff1a\u5982\u4f55\u901a\u8fc7\u6539\u8fdbMCTS\u7684\u9009\u62e9\u7b56\u7565\u548cPRM\u7684\u53c2\u6570\u8c03\u6574\u673a\u5236\uff0c\u63d0\u5347\u7b97\u6cd5\u7684\u8ba1\u7b97\u6548\u7387\uff1f\n2. **\u5e76\u884c\u8ba1\u7b97**\uff1a\u5982\u4f55\u5229\u7528\u5e76\u884c\u8ba1\u7b97\u6280\u672f\uff0c\u52a0\u901fMCTS\u7684\u6a21\u62df\u548c\u56de\u6eaf\u8fc7\u7a0b\uff0c\u4ece\u800c\u964d\u4f4e\u8ba1\u7b97\u590d\u6742\u5ea6\uff1f\n3. **\u6570\u636e\u7ed3\u6784\u4f18\u5316**\uff1a\u5982\u4f55\u4f18\u5316MCTS\u7684\u6570\u636e\u7ed3\u6784\uff0c\u51cf\u5c11\u5185\u5b58\u5360\u7528\u548c\u8ba1\u7b97\u65f6\u95f4\uff0c\u63d0\u5347\u6574\u4f53\u6548\u7387\uff1f\n4. **\u542f\u53d1\u5f0f\u65b9\u6cd5**\uff1a\u5982\u4f55\u5f15\u5165\u542f\u53d1\u5f0f\u65b9\u6cd5\uff0c\u51cf\u5c11MCTS\u7684\u641c\u7d22\u7a7a\u95f4\uff0c\u4ece\u800c\u964d\u4f4e\u8ba1\u7b97\u590d\u6742\u5ea6\uff1f\n\n\u901a\u8fc7\u63a2\u8ba8\u8fd9\u4e9b\u95ee\u9898\uff0c\u53ef\u4ee5\u4e3a\u8fdb\u4e00\u6b65\u4f18\u5316MCTS\u7684\u8ba1\u7b97\u6548\u7387\u63d0\u4f9b\u65b0\u7684\u601d\u8def\u548c\u65b9\u6cd5\uff0c\u63a8\u52a8MCTS\u4e0ePRM\u7ed3\u5408\u6280\u672f\u7684\u5e7f\u6cdb\u5e94\u7528\u3002\u300d\n", "589d43ac-52eb-46d5-a6e1-797b6c59a64e:\u300cref_ids: 454846649385965806, chunk_ids: 1, Score: 0.5586, Text: # 2.2 Acceleration of MCTS\nMCTS-based methods have proved their strong capability of solving complex games or tasks. However, the high computational cost of MCTS hinders its application to some real-time and more general scenarios. Therefore, numerous works are devoted to accelerating MCTS. For example, to make the selection stage more effective, some heuristic pruning methods [ 14 ,33 ,29 ,1 ,2 ] aim to reduce the width and depth of the search tree with some heuristic functions. Furthermore, for more efficient evaluations, Lorentz [ 22 ] proposed early playout termination of MCTS (MCTS-EPT) to stop the random playouts early and use an evaluation function to assess win or loss. Moreover, Hsueh et al. [18 ] applied MCTS-EPT to the Chinese dark chess and proved its effectiveness. Afterward, similar ideas have been applied in the evaluation stage of AlphaGoZero [ 32 ] and later MCTS-based methods [31 ,27 ,34 ]. They evaluate the $Q$ -values through a learnable evaluation network instead of running playouts to the end. Grill et al. [15 ] propose a novel regularized policy optimization method based on AlphaZero to decrease the search budget of MCTS, which is from the optimization perspective. Danihelka et al. [10 ] propose a policy improvement algorithm based on sampling actions without replacement, named Gumbel trick to achieve better performance when planning with few simulations. However, these methods mentioned above focus on the specific stage of the search iteration or reduce the total budget through pruning and optimization methods, which are orthogonal to us. And few works targets at the search loop. Lan et al. [21 ] propose DS-MCTS, which defines the uncertainty of MCTS and approximates it by extra DNNs with specific features for board games in training. During the evaluation, DS-MCTS will check periodically and stop the search if the state is certain.\n\n# 3 Background\nThe AlphaGo series of work [ 30 ,32 ,31 ,27 ] are all MCTS-based reinforcement learning algorithms. Those algorithms assume the environment transition dynamics are known or learn the environment dynamics. Based on the dynamics, they use the Monte-Carlo tree search (MCTS) as the policy improvement operator. I.e., taking in the current policy, MCTS returns a better policy with the search algorithm. The systematic search allows the MCTS-based RL algorithm to quickly improve the policy and perform much better in the setting where heavy reasoning is required.\n\n# 3.1 MCTS\nThis part briefly introduces the MCTS method implemented in reinforcement learning applications. As mentioned in the related works, modern MCTS-based RL algorithms include four stages in the search loop, namely selection, expansion, evaluation, and backpropagation.  \n\nMCTS takes in the current states and generates a policy after the search loop of $N$ iterations. Here $N$ is a constant number of iterations set by the designer, regarded as the total budget. In the selection stage of each iteration, an action will be selected by maximizing over UCB. Specifically, AlphaZero [31 ] and MuZero [ 27 ] are developed based on a variant of UCB, P-UCT [ 25 ] and have achieved great success on board games and Atari games. The formula of P-UCT is the Eq (1):  \n\n$$\na^{k}=\\\\arg\\\\operatorname*{max}_{a\\\\in\\\\mathcal{A}}Q(s,a)+P(s,a)\\\\frac{\\\\sqrt{\\\\sum_{b\\\\in\\\\mathcal{A}}N(s,b)}}{1+N(s,a)}(c_{1}+\\\\log((\\\\sum_{b\\\\in\\\\mathcal{A}}N(s,b)+c_{2}+1)/c_{2})),\n$$  \n\nwhere $k$ is the index of iteration, $\\\\boldsymbol{\\\\mathcal{A}}$ is the acti $Q(s,a)$ is the estimated Q-value, $P(s,a)$ is the policy prior obtained from neural networks, $N(s,a)$ is the visitations to select the action a from the state $s$ and $c_{1},c_{2}$ are hyper-parameters. The output of MCTS is the visitation of each action of the root node. After $N$ search iterations, the final policy $\\\\pi(s)$ is defined as the normalized root visitation distribution simplification, we use $\\\\pi_{N}(s)$ $\\\\pi_{k}$ in place of , where $\\\\begin{array}{r}{\\\\pi_{k}(s,a)=N(s,a)/\\\\sum_{b\\\\in\\\\mathcal{A}}N(s,b)=N(s,a)/k,a\\\\in\\\\mathcal{A}}\\\\end{array}$ $\\\\pi_{k}(s)$ sometimes. And the detailed procedure of MCTS is \u2208A . For introduced in Appendix. In our method, we propose to approximate the final policy $\\\\pi_{N}(s)$ with $\\\\hat{\\\\pi}_{k}(s)$ ,which we name as a virtual expanded policy, through a new expansion method and a termination rule. In this way, the number of iterations in MCTS can be reduced from $N$ to $k$ .\n\n# 3.2 Computation Requirement\nMost of the computations in MCTS-based RL are in the MCTS procedure. Each action taken by MCTS requires $N$ times neural network evaluations, where $N$ is a constant number of iterations in the search loop. Traditional RL algorithms, such as PPO [ 28 ] or DQN [ 23 ], only need a single neural network evaluation per action. Thus, MCTS-based RL is roughly $N$ times computationally more expensive than traditional RL algorithms. In practice, training a single Atari game needs 12 hours of computation time on 40 TPUs [ 27 ]. The computation need is roughly two orders of magnitude more than traditional RL algorithms [28], although the final performance of MuZero is much better.\n\n# 4 Method\nWe aim to spend more search time on harder states and less on easier states. Intuitively, human knows when to make a quick decision or a slow decision under different circumstances. Unfortunately, this situation-aware behavior is absent in current MCTS algorithms. Therefore, we propose an MCTS variant that terminates the search iteration adaptively. It consists of two components: a novel expansion method named virtual expansion to estimate the final visitation based on the current partial tree; a termination rule that decides when to terminate based on the hardness of the current scenario. And we will display the adaptive mechanism through visualizations in Section 5.5.\u300d\n", "589d43ac-52eb-46d5-a6e1-797b6c59a64e:\u300cref_ids: 454845581169535994, chunk_ids: 7, Score: 0.4844, Text: # Spending Thinking Time Wisely: Accelerating MCTS with Virtual Expansions\nWeirui $\\\\mathbf{Ye}^{*}$ Pieter Abbeel \u2020Yang Gao $\\\\ast\\\\ddag\\\\S$ \u2217Tsinghua University, \u2020UC Berkeley, \u00a7Shanghai Qi Zhi Institute\n\n# Abstract\nOne of the most important AI research questions is to trade off computation versus performance since \u201cperfect rationality\" exists in theory but is impossible to achieve in practice. Recently, Monte-Carlo tree search (MCTS) has attracted considerable attention due to the significant performance improvement in various challenging domains. However, the expensive time cost during search severely restricts its scope for applications. This paper proposes the Virtual MCTS (V-MCTS), a variant of MCTS that spends more search time on harder states and less search time on simpler states adaptively. We give theoretical bounds of the proposed method and evaluate the performance and computations on $9\\\\times9$ Go board games and Atari games. Experiments show that our method can achieve comparable performances to the original search algorithm while requiring less than $50\\\\%$ search time on average. We believe that this approach is a viable alternative for tasks under limited time and resources. The code is available at https://github.com/YeWR/V-MCTS.git .\n\n# 1 Introduction\nWhen artificial intelligence was first studied in the 1950s, researchers have sought to find the solution to the question \u201cHow to build an agent with perfect rationality\". The term \u201cperfect rationality\" [7 ,24 ,26 ] here refers to the decision made with infinite amounts of computations. However, one can only solve small-scale problems without considering the practical computation time since classical search algorithms usually exhibit exponential running time. Therefore, recent AI research would no longer seek to achieve \u201cperfect rationality\", but instead carefully trade-off computation versus the level of rationality. People have developed computational models like \u201cbounded optimality\" to model these settings [ 26 ]. The increasing level of rationality under the same computational budget has given us a lot of AI successes. Algorithms include the Monte-Carlo sampling algorithms, the variational inference algorithms, and using DNNs as universal function approximators [9, 8, 13, 30, 17].  \n\nRecently, MCTS-based RL algorithms have achieved much success, mainly on board games. The most notable achievement is that AlphaGo beats Hui Fan in 2015 [ 30 ]. It is the first time a computer program beat a human professional Go player. Afterward, AlphaGo beats two top-ranking human players, Lee Sedol in 2016 and Jie Ke in 2017, the latter of which ranked first worldwide at the time. Later, MCTS-based RL algorithms were further extended to other board games and Atari games [ 27 ]. EfficientZero [ 34 ] significantly improves the sample efficiency of MCTS-based RL algorithms, shedding light on its future applications in the real world like robotics and self-driving.  \n\nDespite the impressive performance of MCTS-based RL algorithms, they require massive amounts of computation to train and evaluate. For example, MuZero [ 27 ] used 1000 TPUs trained for 12 hours to learn the game of Go, and for a single Atari game, it needs 40 TPUs to train 12 hours. Compared to previous algorithms on the Atari games benchmark, it needs around two orders of magnitude more compute. This prohibitively large computational requirement has slowed down both the further development of MCTS-based RL algorithms as well as its practical use.  \n\nUnder the hood, MCTS-based RL algorithms imagine the futures when taking different future action sequences. However, this imaging process for the current method is not computationally efficient. For example, AlphaGo needs to look ahead 1600 game states to place a single stone. On the contrary, top human professional players can only think through around 100-200 game states per minute [ 30 ]. Apart from the inefficiency, the current MCTS algorithm deals with easy and challenging cases with the same computational budget. However, human knows to use their time when it is most needed.  \n\nIn this paper, we aim to design new algorithms that save the computational time of the MCTSbased RL methods. We make three key contributions : (1) We present Virtual MCTS, a variant of MCTS, to approximate the vanilla MCTS search policies with less computation. Moreover, unlike previous pruning-based methods that focus on the selection or evaluation stage in MCTS, our method improves the search loop. It terminates the search iterations earlier adaptively when current states are simpler; (2) Theoretically, we provide some error bounds of the proposed method. Furthermore, the visualization results indicate that Virtual MCTS has a better computation and performance trade-off than vanilla MCTS; (3) Empirically, our method can save more than $50\\\\%$ of search times on the challenging game Go $9\\\\times9$ and more than $60\\\\%$ on the visually complex Atari games while keeping comparable performances to those of vanilla MCTS.\n\n# 2 Related Work\n\n# 2.1 Reinforcement Learning with MCTS\nFor a long time, Computer Go has been regarded as a remarkably challenging game [ 3 ,6 ]. Researchers attempt to use Monte-Carlo techniques that evaluate the value of the node state through random playouts [ 4 ,11 ,12 ,30 ]. Afterward, UCT algorithms have generally been applied in Monte-Carlo tree search (MCTS) algorithms, which use UCB1 to select action at each node of the tree [ 20 ]. Recently, MCTS-based RL methods [ 30 ,32 ,31 ,27 ] have become increasingly popular and achieved super-human performances on board games because of their strong ability to search.  \n\nModern MCTS-based RL algorithms include four stages in the search loop : selection, expansion, evaluation, and backpropagation. The computation bottlenecks in vanilla MCTS come from the search loop, especially for the evaluation stage and the selection stage of each iteration. The selection stage is time-consuming when the search tree becomes wider and deeper. The evaluation stage is quite expensive because people attempt to evaluate the node value by random playouts to the end in previous researches. Due to the search loop, MCTS-based algorithms have multiple model inferences compared to other model-free RL methods like PPO [28] and SAC [16].\u300d\n", "589d43ac-52eb-46d5-a6e1-797b6c59a64e:\u300cref_ids: 454845771530662550, chunk_ids: 1, Score: 0.4590, Text: # 5 Experiment\nTo examine the performance of MCTS-VS, we conduct experiments on different tasks, including synthetic functions, NAS-bench problems and MuJoCo locomotion tasks, to compare MCTS-VS with other black-box optimization methods. For MCTS-VS, we use the same hyper-parameters except $C_{p}$ , which is used for calculating UCB in Eq. (1). For Dropout and embedding-based methods, we set the parameter $d$ to the number of valid dimensions for synthetic functions, and a reasonable value for real-world problems. The hyper-parameters of the same components of different methods are set to the same. We use five identical random seeds (2021\u20132025) for all problems and methods. More details about the settings can be found in Appendix C. Our code is available at https://github.com/lamda-bbo/MCTS-VS .\u300d\n"]}}, "__type__": "1"}}, "template_store/metadata": {"db35390a-5d02-422f-af49-99c0ef221ede": {"template_hash": ""}}}