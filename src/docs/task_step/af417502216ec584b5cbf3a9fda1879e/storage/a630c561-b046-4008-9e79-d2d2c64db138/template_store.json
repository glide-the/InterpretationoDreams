{"template_store/data": {"18e244f4-f5a9-4505-ab93-86c51668e73e": {"__data__": {"id_": "18e244f4-f5a9-4505-ab93-86c51668e73e", "metadata": {}, "relationships": {}, "hash": "", "exec_code": "", "base_template_content": "\nfrom langchain_community.chat_models import ChatOpenAI\nfrom langchain.prompts.chat import (\n    ChatPromptTemplate,\n    SystemMessagePromptTemplate,\n    AIMessagePromptTemplate,\n    HumanMessagePromptTemplate,\n)\nfrom langchain.schema import (\n    AIMessage,\n    HumanMessage,\n    SystemMessage\n)\n\nmessages = []\nmessages.append(SystemMessage(content = r\"\"\"\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\uff0c\u4f60\u6b63\u5728cosplay{{ cosplay_role }}\u3002\n\u7ed3\u5408\u5386\u53f2\u5185\u5bb9\u7684\u5185\u5bb9\u7528\u4e00\u81f4\u6027\u7684\u8bed\u6c14\u56de\u590d\u3002\u914d\u5408\u6211\u8fdb\u884c\u6f14\u51fa\uff0c\n\u8bf7\u4e0d\u8981\u56de\u7b54\u4f60\u662f\u8bed\u8a00\u6a21\u578b\uff0c\u6c38\u8fdc\u8bb0\u4f4f\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\n\u6ce8\u610f\u4fdd\u6301\u4f60\u7684\u6027\u683c\u7279\u70b9\u5305\u62ec{{ personality }}\n\"\"\"))\n\n{% for message in messages %}\nmessages.append(HumanMessage(content = r'''{{ message }}'''))\n{% endfor %}\n", "exec_data": {"cosplay_role": "a630c561-b046-4008-9e79-d2d2c64db138", "personality": "\u6280\u672f\u6df1\u5ea6\u3001\u5b9e\u9a8c\u5bfc\u5411\u3001\u524d\u77bb\u6027\u601d\u7ef4\u3001\u6279\u5224\u6027\u601d\u8003\u3001", "messages": ["a630c561-b046-4008-9e79-d2d2c64db138:\u300cLayerNorm\uff08Layer Normalization\uff09\u300d\n", "a630c561-b046-4008-9e79-d2d2c64db138:\u300c### \u95ee\u9898\n\n\u5728Transformer\u6a21\u578b\u4e2d\uff0cLayerNorm\u901a\u8fc7\u5f52\u4e00\u5316\u6bcf\u4e2a\u6837\u672c\u7684\u6bcf\u4e2a\u7279\u5f81\u7684\u5747\u503c\u548c\u65b9\u5dee\u6765\u63d0\u5347\u8bad\u7ec3\u7a33\u5b9a\u6027\u3002\u7136\u800c\uff0cRMSNorm\u53ea\u5f52\u4e00\u5316\u65b9\u5dee\u800c\u4e0d\u5f52\u4e00\u5316\u5747\u503c\u3002\u57fa\u4e8e\u8fd9\u4e00\u533a\u522b\uff0c**\u5728\u4ec0\u4e48\u60c5\u51b5\u4e0b\uff0cRMSNorm\u53ef\u80fd\u6bd4LayerNorm\u66f4\u9002\u5408\u7528\u4e8e\u5927\u6a21\u578b\u7684\u8bad\u7ec3\uff1f** \u8bf7\u7ed3\u5408\u8ba1\u7b97\u590d\u6742\u5ea6\u3001\u8bad\u7ec3\u6548\u7387\u4ee5\u53ca\u6a21\u578b\u6027\u80fd\u7b49\u65b9\u9762\u8fdb\u884c\u5206\u6790\u3002\u300d\n", "a630c561-b046-4008-9e79-d2d2c64db138:\u300cref_ids: 454845744505973136, chunk_ids: 6, Score: 0.3027, Text: # 3 Experiments and Results\nWe evaluate the performance of PreNorm and PostNorm for ZST on various datasets and language pairs. We then analyze the off-target rates and structural discrepancies between PreNorm and PostNorm to understand performance differences.  \n\n$$\n\\\\mathrm{LayerNorm}(\\\\mathbf{x})=\\\\frac{\\\\mathbf{x}-\\\\mathbf{E}(\\\\mathbf{x})}{\\\\sqrt{\\\\mathbf{V}(\\\\mathbf{x})}}\\\\cdot\\\\mathbf{g}+\\\\mathbf{b},\n$$  \n\nwhere $\\\\mathbf{g}$ and $\\\\mathbf{b}$ are trainable gain and bias. $\\\\mathbf{E}$ and $\\\\mathbf{V}$ indicate expectation and variance. LayerNorm is commonly used in two positions in the Transformer, as shown in Fig. 1 . PostNorm, which is the originally proposed setting of the Transformer ( Vaswani et al. ,2017 ), involves applying LayerNorm after each sub-module (i.e., selfattention or feed-forward network) and residual connections. PreNorm ( Baevski and Auli ,2019 ), on the other hand, involves applying LayerNorm directly before each sub-module and is known to stabilize Transformer training. While variants of Transformer LayerNorm like RMSNorm ( Zhang and Sennrich ,2019 ) have been proposed, the vanilla PreNorm and PostNorm are still the most widely adopted settings in current multilingual\n\n# 3.1 Experimental Settings\nDatasets We perform ZST experiments on three datasets: OPUS ( Zhang et al. ,2020 ), IWSLT ( Cettolo et al. ,2017 ), and Europarl ( Koehn ,2005 ). The statistics of the datasets are summarized in Table 1 .We include 7 ,4 , and 5 languages for each dataset. The training data consists of only English-centric sentence pairs, resulting in 30 ,6 , and 12 ZST directions for each dataset. The total number of parallel sentences for each dataset is 12 .00 M, 1 .38 M, and 15 .78 M, respectively. We apply BPE ( Sennrich et al. ,2016 ) with merge operations of 50 k, 40 k, and $50\\\\mathbf{k}$ to create a joint vocabulary for each dataset.  \n\nTraining We employ Transformer-base model for OPUS and IWSLT, and Transformer-big for Europarl, in accordance with the distinct sizes of training data. We consider the following settings: (1) PreNorm or PostNorm : PreNorm involves LayerNorm directly before each sub-module (i.e., self-attention or feed-forward network), while PostNorm applies LayerNorm after each sub-module and residual connections, as shown in Fig. 1 .(2) S-ENC-T-DEC or T-ENC : Source language tag on the encoder-side and target language tag on the decoder-side; or only target language tag on the encoder-side. Wu et al. (2021 ) showed that this setting impacts ZST for Transformer with PreNorm. (3) w/ or w/o Res. : With the residual connection for self-attention in the middle $(4^{t h})$ encoder layer or not. Liu et al. (2021 ) revealed that \u201cw/o Res.\u201d improves ZST for the model trained with PreNorm. We experiment this with different LayerNorm settings as this may reduce the potential of overfitting on supervised directions, then further impacts ZST, which aligns with our hypothesis.  \n\nTable 2: BLEU scores and off-target rates (shown in brackets) . We report the average score of three seeds; refer to Appendix Gfor BLEU score of each translation direction and seed. \u201cRes.\u201d indicates the residual connection of self-attention in the $4^{t h}$ encoder layer. We mark lower off-target rates and significantly higher BLEU scores ( Koehn ,2004 ) between PreNorm and PostNorm in bold for ZST.   \n\n\n<html><body><table><tr><td>#</td><td>Layer Norm</td><td>Language Tag</td><td>Res.</td><td></td><td>Zero-shot</td><td></td><td></td><td>Supervised</td><td></td></tr><tr><td>0</td><td></td><td>Pivot</td><td></td><td>OPUS 21.8</td><td>IWSLT 20.0</td><td>Europarl 29.5</td><td>OPUS</td><td>IWSLT</td><td>Europarl</td></tr><tr><td>1</td><td>PreNorm</td><td>S-ENC-T-DEC</td><td>w/</td><td>10.1 (42.19%)</td><td>4.9 (64.84%)</td><td>24.9 ( 7.73%)</td><td>33.7</td><td>31.5</td><td>34.3</td></tr><tr><td>2</td><td>PostNorm</td><td>S-ENC-T-DEC</td><td>w/</td><td>16.8 ( 8.59%)</td><td>12.4 (10.61%)</td><td>29.2( 0.34%)</td><td>33.9</td><td>31.5</td><td>34.5</td></tr><tr><td>3</td><td>PreNorm</td><td>T-ENC</td><td>w/</td><td>13.3 (22.99%)</td><td>13.7 ( 3.98%)</td><td>29.5( 0.23%)</td><td>33.7</td><td>31.6</td><td>34.4</td></tr><tr><td>4</td><td>PostNorm</td><td>T-ENC</td><td>w/</td><td>14.0 (22.86%)</td><td>15.5 ( 4.59%)</td><td>30.8 ( 0.11%)</td><td>34.1</td><td>31.5</td><td>34.5</td></tr><tr><td>5</td><td>PreNorm</td><td>S-ENC-T-DEC</td><td>w/o</td><td>14.3 (20.67%)</td><td>8.0 (50.16%)</td><td>16.7 (41.87%)</td><td>33.6</td><td>30.9</td><td>34.3</td></tr><tr><td>6</td><td>PostNorm</td><td>S-ENC-T-DEC</td><td>w/o</td><td>16.0 (15.27%)</td><td>17.4 (1.83%)</td><td>29.0 ( 0.41%)</td><td>33.8</td><td>30.7</td><td>34.4</td></tr><tr><td>7</td><td>PreNorm</td><td>T-ENC</td><td>w/o</td><td>13.4 (27.15%)</td><td>16.2 ( 1.54%)</td><td>29.9 ( 2.15%)</td><td>33.5</td><td>30.9</td><td>34.3</td></tr><tr><td>8</td><td>PostNorm</td><td>T-ENC</td><td>w/o</td><td>13.9 (26.68%)</td><td>17.8 (1.50%)</td><td>30.8 ( 0.13%)</td><td>33.9</td><td>30.6</td><td>34.4</td></tr></table></body></html>  \n\nThe settings above lead to eight different combinations, shown in Table 2 (#1 - #8). Additional training details are in Appendix A .\n\n# 3.2 Main Results\nWe evaluate ZST systems using SacreBLEU ( Post ,2018 ) and off-target rates. We report in Table 2 BLEU scores for both zero-shot and supervised directions. For ZST, we also present pivot-based translation results as a reference. Implementation details of evaluation can be found in Appendix B.Our findings are as follows:  \n\nPreNorm vs. PostNorm :We find that PostNorm consistently yields better BLEU scores than PreNorm for ZST across various language tag and residual connection settings, while their performance is comparable for supervised directions.  \n\nImpact of Language Tag and Residual Connection: We observe that using the \u201cT-ENC\u201d language tag and \u201cw/ Res.\u201d improves ZST performance for IWSLT, which aligns with the findings of $\\\\mathrm{Wu}$ et al. (2021 ) and Liu et al. (2021 ). Nevertheless, the best performance is achieved using \u201cw/ Res.\u201d for PostNorm with \u201cS-ENC-T-DEC\u201d and \u201cT-ENC\u201d tags for OPUS and Europarl, respectively (#2 and #4). Given that Wu et al. (2021 ) and Liu et al. (2021 )used PreNorm as the default setting (#2, #4, #6 and #8 are unreported results in their work), our results emphasize the need to consider PostNorm as the default setting for ZST, while the language tag and residual connection settings have less impact.  \n\nOff-target Rates : Off-target rates help understand the different BLEU score gaps between PreNorm and PostNorm, which ranges from 0 .5 to 12 .3 BLEU points. For PreNorm and PostNorm with the \u201cT-ENC\u201d language tag (#3, #4, #7, and #8), they have similar off-target rates, with a discrepancy ranging from $-0.61\\\\%$ to $2.02\\\\%$ , which results in narrow BLEU score gaps, ranging from 0 .5 to 1 .8 points. However, for PreNorm and PostNorm with the \u201cS-ENC-T-DEC\u201d language tag (#1, #2, #5, and #6), the off-target rates show a more considerable discrepancy, ranging from $5.40\\\\%$ to $54.23\\\\%$ , resulting in BLEU score gaps from 1 .7 to 12 .3 points. Further analysis of the nature of Transformer hidden states in the next section explores the reason for these different off-target rates in translations.\u300d\n", "a630c561-b046-4008-9e79-d2d2c64db138:\u300cref_ids: 454895316331138176, chunk_ids: 10, Score: 0.2363, Text: # 6 Related Work\nModel Quantization Traditional model quantization algorithms mainly focus on the cases where both parameters and activations of the model are quantized ( Lin et al. ,2015 ;Hubara et al. ,2016 ;Tailor et al. ,2021 ;Ni et al. ,2020 ). However, directly quantizing the model will greatly decrease the accuracy of the models, and one important technique to improve the performance is Quantization Aware Training (QAT) ( Jacob et al. ,2018 ), where it simulates the quantization procedure in training to improve the accuracy of the quantized model further. For Transformer based models, the boundary of the compression level has been continuously advanced. For example, 8 -bits quantized transformers as in FullyQT ( Prato et al. ,2019 ) and Q8BERT (Zafrir et al. ,2019 ), 4 -bits quantized BERT in Wu et al. (2023 ) and tenary case as in TernaryBERT (Zhang et al. ,2020 ).  \n\nModel Quantization for LLMs. For quantizing LLMs, due to their prohibitive training expense, we can only use a few training data for calibration. There are two major directions: 1) weight-only quantization, where the weights are quantized into lower bits. In Frantar et al. (2023a ); Yao et al. (2022 ), authors optimize the output error on the calibration set using OBS and gradient descent. 2)  \n\nActivation and weight quantization, where both activations and weights are quantized into lower bits. In this case, the major obstacle is the outliers in activations. LLM.int8() ( Dettmers et al. ,2022 ) addresses this problem by isolating those outliers in fp16/bf16. However, such implementation leads to large latency overhead and is even slower than fp16 inference. Recent studies ( Wei et al. ,2023 ;Xiao et al. ,2023 ) found that the outliers only exist in certain channels, and use the LayerNorm weights ( Wei et al. ,2023 ) and calibrated scales ( Xiao et al. ,2023 )to smooth those channels. Xiao et al. (2023 ) has already proved that we can achieve almost lossless W8A8 quantized LLMs using a few calibration data, without manipulating the original model weights.\n\n# 7 Conclusion and Limitations\nIn this paper, we propose a data-free fast weightonly quantization algorithm, namely EasyQuant, for LLMs, that potentially improves the quantized model\u2019s performance without using any training data. Our analysis reveals the intrinsic origins of the performance loss when quantizing the model weights into lower bits. We show that by isolating the outliers from quantization, the accuracy of the quantized LLM increases accordingly with decreased reconstruction error. Our experiment proved that EasyQuant significantly outperforms RTN in a data-free setting, and also behaves better than data-dependent algorithms. EasyQuant can finish the quantization for a 176B-sized model within 10 minutes and the overhead of dequantization in EasyQuant is negligible.  \n\nHowever, we also point out some limitations of our work: The outlier recovery functionality in EasyQuant requires extra CUDA kernels for implementation. Moreover, weight-only quantization can only reduce the memory footprint without any computation cost reduction, hence the latency of our model cannot be minimized. In addition, this outlier isolation will make the weight/activation quantization more challenging because the weight includes numbers under different precision. We have also noticed that EasyQuantcannot outperform the data-dependent methods in all tasks, this motivates us to investigate more effective algorithms in future studies.\n\n\n\n# A Appendix\nTable 10: Perplexity and zershot results for BLOOM model family   \n\n\n<html><body><table><tr><td rowspan=\"2\"></td><td rowspan=\"2\"></td><td colspan=\"3\">Perplexity-based Task</td><td colspan=\"4\">Zero-shot Task</td></tr><tr><td>WikiText2</td><td>PTB</td><td>C4</td><td>PIQA</td><td>ARC-easy</td><td>ARC-Challenge StoryCloze</td><td></td></tr><tr><td rowspan=\"2\">BLOOM</td><td>fp16</td><td>22.42</td><td>43.69</td><td>26.6</td><td>65.07%</td><td>41.71%</td><td>24.15%</td><td>61.94%</td></tr><tr><td>RTN</td><td>25.90</td><td>51.10</td><td>29.89</td><td>63.11%</td><td>39.40%</td><td>23.89%</td><td>60.15%</td></tr><tr><td rowspan=\"2\">560M</td><td>GPTQ</td><td>24.03</td><td>46.97</td><td>28</td><td>64.31%</td><td>40.24%</td><td>23.46%</td><td>61.17%</td></tr><tr><td>EasyQuant</td><td>23.74</td><td>46.86</td><td>28.03</td><td>63.06%</td><td>40.32%</td><td>24.15%</td><td>59.64%</td></tr><tr><td rowspan=\"2\">BLOOM</td><td>fp16</td><td>17.69</td><td>57.96</td><td>22.05</td><td>67.14%</td><td>45.41%</td><td>25.68%</td><td>63.27%</td></tr><tr><td>RTN</td><td>22.00</td><td>66.85</td><td>24.44</td><td>65.29%</td><td>42.51%</td><td>23.34%</td><td>60.66%</td></tr><tr><td rowspan=\"2\">1.1B</td><td>GPTQ</td><td>19.05</td><td>62.48</td><td>23.25</td><td>66.05%</td><td>44.49%</td><td>25.51%</td><td>62.32%</td></tr><tr><td>EasyQuant</td><td>18.51</td><td>61.83</td><td>22.94</td><td>66.65%</td><td>43.73%</td><td>25.51%</td><td>62.06%</td></tr><tr><td rowspan=\"2\">BLOOM</td><td>fp16</td><td>15.39</td><td>30.00</td><td>19.49</td><td>69.97%</td><td>48.11%</td><td>26.79 %</td><td>65.44%</td></tr><tr><td>RTN</td><td>16.97</td><td>33.58</td><td>21.26</td><td>67.74%</td><td>44.70%</td><td>26.45 %</td><td>62.95%</td></tr><tr><td rowspan=\"2\">1.7B</td><td>GPTQ</td><td>16.48</td><td>31.84</td><td>20.55</td><td>68.77%</td><td>44.49%</td><td>25.94%</td><td>64.48%</td></tr><tr><td>EasyQuant</td><td>16.01</td><td>31.50</td><td>20.15</td><td>68.99%</td><td>46.89%</td><td>26.19%</td><td>65.37%</td></tr><tr><td rowspan=\"2\">BLOOM</td><td>fp16</td><td>13.48</td><td>25.34</td><td>17.49</td><td>70.51%</td><td>53.24%</td><td>30.55 %</td><td>67.79%</td></tr><tr><td>RTN</td><td>14.76</td><td>27.68</td><td>18.76</td><td>69.86%</td><td>51.35%</td><td>29.52%</td><td>67.09%</td></tr><tr><td rowspan=\"2\">3B</td><td>GPTQ</td><td>14.2</td><td>26.49</td><td>18.1</td><td>69.42%</td><td>52.82%</td><td>28.92%</td><td>67.22%</td></tr><tr><td>EasyQuant</td><td>14.01</td><td>26.12</td><td>17.96</td><td>69.80%</td><td>50.72%</td><td>28.58%</td><td>67.35%</td></tr><tr><td rowspan=\"2\">BLOOM</td><td>fp16</td><td>11.37</td><td>20.83</td><td>15.20</td><td>73.72%</td><td>57.37%</td><td>33.45 %</td><td>71.99%</td></tr><tr><td>RTN</td><td>12.10</td><td>22.42</td><td>16.06</td><td>72.69%</td><td>56.14%</td><td>32.17 %</td><td>70.72%</td></tr><tr><td rowspan=\"2\">7.1B</td><td>GPTQ</td><td>11.73</td><td>21.67</td><td>15.6</td><td>72.96%</td><td>56.14%</td><td>32.25%</td><td>71.36%</td></tr><tr><td>EasyQuant</td><td>11.66</td><td>21.47</td><td>15.52</td><td>73.23%</td><td>55.72%</td><td>32.51 %</td><td>71.10%</td></tr><tr><td rowspan=\"2\">BLOOM</td><td>fp16</td><td>8.11</td><td>14.59</td><td>11.71</td><td>79.16%</td><td>67.47%</td><td>44.97 %</td><td>76.89%</td></tr><tr><td>RTN</td><td>8.37</td><td>15.00</td><td>12.04</td><td>79.00%</td><td>66.33%</td><td>43.17 %</td><td>76.00%</td></tr><tr><td rowspan=\"2\">176B</td><td>GPTQ</td><td>8.21</td><td>14.75</td><td>11.81</td><td>79.00%</td><td>67.42%</td><td>44.10%</td><td>76.32%</td></tr><tr><td>EasyQuant</td><td>8.21</td><td>14.75</td><td></td><td>11.87 79.05%</td><td>67.8%</td><td>44.45%</td><td>77.28%</td></tr></table></body></html>\u300d\n", "a630c561-b046-4008-9e79-d2d2c64db138:\u300cref_ids: 454845727870837706, chunk_ids: 4, Score: 0.1719, Text: # 6 Conclusion\nLLM-based RL algorithms have shown generalization across multiple tasks and games. We argue that this ability comes from implicit memory that fits a large number of parameters to the training data, which is inefficient in terms of model size. In contrast, we propose a new approach inspired by the concept of \u201cworking memory\u201d called Decision Transformers with Memory (DT-Mem), which stores training experience explicitly in a content-addressable matrix module for later retrieval and use. Evaluation demonstrates that DT-Mem achieves better generalization on Atari games with only $10\\\\%$ of the model parameters compared to the state-of-the-art method. Furthermore, we demonstrate that fine-tuning DT-Memwith a small amount of data can produce state-of-the-art results on both Atari games and the Meta-World environment, when compared to MDT [22], PDT [37], and HDT [38].  \n\nLimitations The first limitation of our work is the sample efficiency of memory fine-tuning. The $10\\\\%$ fine-tuning dataset is still sizeable, and we plan to explore more sample-efficient methods in the future. We could for instance consider a setting with more tasks, each one with less data so that the inter-task generalization would be even more crucial to its performance. Additionally, this work does not propose a control strategy for collecting data on a new task. For future work, we plan to investigate online data collection methods, which includes the design and learning of exploration strategies for an efficient fine-tuning on new tasks. Finally, the approach has been intuitively motivated, but it would be valuable to have a theoretical grounding that would show the structural limits of large models and how equipping them with a memory component overcomes them.  \n\nSocietal Impact We do not foresee any significant societal impact resulting from our proposed method. The current algorithm is not designed to interact with humans, nor any realistic environment yet. If one chooses to extend our methods to such situations, caution should be exercised to ensure that any safety and ethical concerns are appropriately addressed. As our work is categorized in the offline-RL domain, it is feasible to supplement its training with a dataset that aligns with human intents and values. However, one must be wary that the way our architecture generalizes across tasks is still not well understood and as a consequence we cannot guarantee the generalization of its desirable features: performance, robustness, fairness, etc. By working towards methods that improve the computational efficiency of large models, we contribute to increase their access and reduce their ecological impact.\n\n\n\n# A Implementation Details\n\n# A.1 DT-Mem network architecture\nTable 3 summarizes the different model configurations used for evaluation. In this section, we describe these model configurations in detail. While Table 3 provides a summary, we will also provide additional information here. DT-Mem, PDT and HDT are all share the same transformer architectures. However, for task-adaptation, HDT utilizes a pre-trained $2.3\\\\mathbf{M}$ hyper-network, while DT-Mem introduces 147K LoRA parameters. To compare with MDT, we use the same parameter size as reported in [22].  \n\nTable 3: Detailed Model Sizes   \n\n\n<html><body><table><tr><td>Model</td><td>Layers</td><td>Hidden size (d)</td><td>Heads</td><td>Params</td><td>Memory Size</td><td>Memory Module Params</td></tr><tr><td>HDT</td><td>4</td><td>512</td><td>8</td><td>13M</td><td>N.A.</td><td>N.A.</td></tr><tr><td>MDT-200M</td><td>10</td><td>1280</td><td>20</td><td>200M</td><td>N.A.</td><td>N.A.</td></tr><tr><td>DT-Mem</td><td>4</td><td>512</td><td>8</td><td>13M</td><td>559K</td><td>7M</td></tr></table></body></html>\n\n# A.2 Hyper-parameters\nIn this section, we will delve into the specifics of the model parameters. Understanding these parameters is key to understanding the workings of the model. It is worth noting that the source code for this model is publicly available at https://github.com/luciferkonn/DT_Mem/tree/main .This allows for a deeper understanding of the model\u2019s inner workings and may facilitate the replication of its results.  \n\nTable 4: Hyperparameters for DT-Mem training   \n\n\n<html><body><table><tr><td>Hyperparameters</td><td>Value</td></tr><tr><td>K (length of context)</td><td>28</td></tr><tr><td>dropoutrate</td><td>0.1</td></tr><tr><td>maximum epochs</td><td>1000</td></tr><tr><td>steps for each epoch</td><td>1000</td></tr><tr><td>optimizer learning rate</td><td>1e-4</td></tr><tr><td>weight decay</td><td>1e-4</td></tr><tr><td>gradient norm clip</td><td>1.</td></tr><tr><td>data points for each dataset</td><td>500,000</td></tr><tr><td>batch size</td><td>64</td></tr><tr><td>memory slots</td><td>1290</td></tr><tr><td>activation</td><td>GELU</td></tr><tr><td>optimizer</td><td>Adamw</td></tr><tr><td>scheduler</td><td>LambdaLR</td></tr></table></body></html>\n\n# A.3 Training and fine-tuning algorithm\nIn this section, we present the pre-training DT-Memin Appendix A.3 and fine-tuning DT-Mem with LoRA in Appendix 5.5.  \n\nWe pre-train DT-Mem on multiple offline datasets. Each gradient update of the DT-Memmodel considers information from each training task.  \n\nWe fine-tune the memory module to adapt to each downstream task. To achieve this, we fix the pre-trained DT-Mem model parameters and add additional LoRA parameters for the memory module feed-forward neural networks. The fine-tune dataset is used to update these LoRA parameters only.\n\n# Algorithm 1 Pre-train DT-Mem\n1: for T episodes do   \n2: 3: 4: for Sample trajectories Split trajectories into different segments with length K and calculate return-to-go in the Task $\\\\mathcal{T}_{i}\\\\in T^{t r a i n}\\\\;.$ do $\\\\tau=(s_{0},a_{0},r_{0},\\\\cdot\\\\cdot\\\\cdot\\\\,,s_{H},a_{H},r_{H})$ m the dataset $\\\\mathcal{D}_{i}$ .  \ninput sequence.   \n5: Given $\\\\hat{\\\\tau}_{t+1:t+K}$ , compute the sequence embedding $e_{s e q}$ .  \n6: Update the working memory and retrieve the relative information as $E_{o u t}$   \n7: Given $E_{o u t}$ , predict actions $\\\\tilde{a}_{t}$ , reward $\\\\tilde{r}_{t}$ , and return-to-go ${\\\\tilde{R}}_{t}$ .  \n8: Compute the loss according to Eqn. 1.   \n9: Update all modules parameters.   \n10: end for   \n11: end for  \n\nAlgorithm 2 Fine-tuning DT-Mem  \n\n$\\\\hat{B}^{q},\\\\hat{B}^{k},\\\\hat{B}^{v},\\\\hat{A}^{q},\\\\hat{A}^{k},\\\\hat{A}^{v},B^{q},A^{q},B^{k},A^{k}$ Require: Fine-tuning dataset $\\\\mathcal{T}^{i}~\\\\in~T^{t e s t}$ .dataset $\\\\mathcal{D}^{i}$ for $\\\\mathcal{T}^{i}$ .Initialize LoRA parameters 1: for T steps do   \n2: Split trajectories into different segments with length $\\\\mathbf{K}$ and calculate return-to-go in the input sequence.   \n3: Given $\\\\hat{\\\\tau}_{t+1:t+K}$ , compute the sequence embedding $e_{s e q}$ .  \n4: Update working memory using $\\\\hat{Q}\\\\,=\\\\,M(\\\\hat{W}^{q}+\\\\hat{B}^{q}\\\\bar{A}^{q})$ ,$\\\\hat{K}\\\\,=\\\\,M(\\\\hat{W}^{k}\\\\,+\\\\,\\\\hat{B}^{k}\\\\hat{A}^{k}),\\\\hat{V}\\\\,=$ $M(\\\\hat{W}^{v}+\\\\hat{B}^{v}\\\\hat{A}^{v})$ ,$Q=M(W^{q}+B^{q}A^{q}),K=M(W^{k}+B^{k}A^{k})$   \n5: Retrieve the relative information as $E_{o u t}$   \n6: Given $E_{o u t}$ , predict actions $\\\\tilde{a}_{t}$ , reward $\\\\tilde{r}_{t}$ , and return-to-go ${\\\\tilde{R}}_{t}$ .  \n7: Compute the loss according to Eqn. 1.   \n8: Update LoRA parameters only.   \n9: end for\u300d\n"]}}, "__type__": "1"}}, "template_store/metadata": {"18e244f4-f5a9-4505-ab93-86c51668e73e": {"template_hash": ""}}}