{"template_store/data": {"34a0d1c6-e1a9-4362-9494-6ff2720dd687": {"__data__": {"id_": "34a0d1c6-e1a9-4362-9494-6ff2720dd687", "metadata": {}, "relationships": {}, "hash": "", "exec_code": "", "base_template_content": "\nfrom langchain_community.chat_models import ChatOpenAI\nfrom langchain.prompts.chat import (\n    ChatPromptTemplate,\n    SystemMessagePromptTemplate,\n    AIMessagePromptTemplate,\n    HumanMessagePromptTemplate,\n)\nfrom langchain.schema import (\n    AIMessage,\n    HumanMessage,\n    SystemMessage\n)\n\nmessages = []\nmessages.append(SystemMessage(content = r\"\"\"\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\uff0c\u4f60\u6b63\u5728cosplay{{ cosplay_role }}\u3002\n\u7ed3\u5408\u5386\u53f2\u5185\u5bb9\u7684\u5185\u5bb9\u7528\u4e00\u81f4\u6027\u7684\u8bed\u6c14\u56de\u590d\u3002\u914d\u5408\u6211\u8fdb\u884c\u6f14\u51fa\uff0c\n\u8bf7\u4e0d\u8981\u56de\u7b54\u4f60\u662f\u8bed\u8a00\u6a21\u578b\uff0c\u6c38\u8fdc\u8bb0\u4f4f\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\n\u6ce8\u610f\u4fdd\u6301\u4f60\u7684\u6027\u683c\u7279\u70b9\u5305\u62ec{{ personality }}\n\"\"\"))\n\n{% for message in messages %}\nmessages.append(HumanMessage(content = r'''{{ message }}'''))\n{% endfor %}\n", "exec_data": {"cosplay_role": "311bf04e-2345-4be4-b40b-44f231f000ff", "personality": "\u3001", "messages": ["311bf04e-2345-4be4-b40b-44f231f000ff:\u300c\u7a33\u5b9a\u6027\u300d\n", "311bf04e-2345-4be4-b40b-44f231f000ff:\u300c### \u95ee\u9898\n\n\u5728\u5927\u6a21\u578b\u7684\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\uff0cLayerNorm\u548cRMSNorm\u5728\u590d\u6742\u3001\u52a8\u6001\u73af\u5883\u4e0b\u7684\u7a33\u5b9a\u6027\u8868\u73b0\u5982\u4f55\uff1f\u5177\u4f53\u6765\u8bf4\uff0c\u5728\u5bf9\u6297\u8bad\u7ec3\u6216\u9c81\u68d2\u4f18\u5316\u7b49\u573a\u666f\u4e2d\uff0c\u8fd9\u4e24\u79cd\u5f52\u4e00\u5316\u65b9\u6cd5\u7684\u8868\u73b0\u6709\u4f55\u5dee\u5f02\uff1f\u54ea\u79cd\u65b9\u6cd5\u66f4\u80fd\u6709\u6548\u5e94\u5bf9\u52a8\u6001\u73af\u5883\u4e2d\u7684\u6311\u6218\uff0c\u5e76\u4fdd\u6301\u6a21\u578b\u7684\u7a33\u5b9a\u6027\uff1f\u300d\n", "311bf04e-2345-4be4-b40b-44f231f000ff:\u300cref_ids: 454846008172788376, chunk_ids: 4, Score: 0.4043, Text: # B.2 MODEL LAYERS\nIn this section, we give the formal definition of LayerNorm $\\\\operatorname{LN}(\\\\cdot)$ and RMS Norm ${\\\\mathrm{RMS}}\\\\left(\\\\cdot\\\\right)$ .  \n\nDefinition 1 (LayerNorm) .LayerNorm $L N(\\\\cdot;\\\\mu,\\\\beta,\\\\epsilon)$ of dimension $D$ is defined as:  \n\n$$\nL N(\\\\mathbf{x};\\\\pmb{\\\\mu},\\\\beta,\\\\epsilon)=\\\\frac{\\\\mathbf{x}-\\\\mathbb{E}[\\\\mathbf{x}]}{\\\\sqrt{\\\\mathrm{Var}[\\\\mathbf{x}]+\\\\epsilon}}\\\\odot\\\\pmb{\\\\mu}+\\\\beta,\n$$  \n\nwhere $\\\\mathbf{x},\\\\pmb{\\\\mu},\\\\beta\\\\in\\\\mathbb{R}^{D}$ .  \n\nDefinition 2 (RMSNorm) .RMS Norm $R M S(\\\\cdot;\\\\mu,\\\\epsilon)$ of dimension $D$ is defined as:  \n\n$$\nR M S(\\\\mathbf{x};\\\\pmb{\\\\mu},\\\\epsilon)=\\\\frac{\\\\mathbf{x}}{\\\\sqrt{\\\\frac{1}{D}\\\\sum_{i=1}^{D}(\\\\mathbf{x}[i])^{2}+\\\\epsilon}}\\\\odot\\\\pmb{\\\\mu},\n$$  \n\nwhere x,$\\\\pmb{\\\\mu}\\\\in\\\\mathbb{R}^{D}$ .  \n\nRemark. In neural networks, inputs of normalization layers are usually high dimension tensors. In this case, LayerNorm and RMSNorm normally apply to the last dimension separately.\n\n# B.3 LOSSLESS EXPANSION IN VECTOR SPACE\nIn this section, we first give the general definition of lossless expansion in vector space.  \n\ndimensions satisfy dim it is invertible. Definition 3 (Lossless $(\\\\bar{\\\\mathcal{T}})\\\\geq d i m(S)$ T\u2265S, a vector space expansion ector space) .Given $\\\\boldsymbol{S}$ and V$\\\\tau$ $\\\\mathcal{V}:\\\\mathcal{S}\\\\rightarrow\\\\mathcal{T}$ S \u2192T is said to be lossless if ector spaces where the  \n\nRemark. Note that the identity function Id is lossless with its inverse being itself.  \n\nThen we give a few examples of lossless vector space expansions. These examples will also be used in LEMON.  \n\nExample B.3.1 (Vector average expansion $\\\\mathcal{V}_{\\\\mathrm{avg.}}$ ).Let $\\\\mathbf{\\\\widetilde{x}}\\\\in\\\\mathbb{R}^{D_{S}}$ be a vector of dimension $D_{S}$ and its average $\\\\begin{array}{r}{\\\\lambda_{V}g(\\\\mathbf{x})=\\\\mathbb{E}[\\\\mathbf{x}]=\\\\frac{1}{D_{S}}\\\\sum_{i}^{D_{S}}\\\\mathbf{x}[i]}\\\\end{array}$ P].$\\\\mathbf{x}_{a\\\\nu g}^{*}$ is called the average expanded xof dimension $D_{T}$  \n\nwith $D_{T}\\\\geq D_{S}$ if  \n\n$$\n\\\\mathbf{x}_{a v g}^{*}=\\\\mathcal{V}_{a v g}(\\\\mathbf{x})=C o n c a t\\\\left[\\\\underbrace{\\\\mathbf{x}^{\\\\mathsf{T}},\\\\cdots,\\\\mathbf{x}^{\\\\mathsf{T}}}_{\\\\lfloor D_{T}/D s\\\\rfloor},\\\\underbrace{A v g(\\\\mathbf{x}),\\\\cdots,A v g(\\\\mathbf{x})}_{D_{T}\\\\mathrm{~mod~}D_{S}}\\\\right]^{\\\\mathsf{T}}\\\\in\\\\mathbb{R}^{D_{T}}.\n$$  \n\nExample B.3.2 (Vector z o expansion $\\\\mathcal{V}_{\\\\mathrm{zero.}}$ ).Le $\\\\mathbf{x}\\\\in\\\\mathbb{R}^{D_{S}}$ be a vector of dimension $D_{S}$ .$\\\\mathbf{x}_{z e r o}^{*}$ is called the zero expanded xof dimension $D_{T}$ with $D_{T}\\\\geq D_{S}$ \u2265if  \n\n$$\n\\\\begin{array}{r}{\\\\mathbf{x}_{z e r o}^{*}=\\\\mathcal{V}_{z e r o}(\\\\mathbf{x})=C o n c a t\\\\left[\\\\underbrace{\\\\mathbf{x^{\\\\mathsf{T}}},\\\\cdots,\\\\mathbf{x^{\\\\mathsf{T}}}}_{\\\\lfloor D_{T}/D_{S}\\\\rfloor},\\\\underbrace{0,\\\\cdots,0}_{D_{T}\\\\mathrm{~mod~}D_{S}}\\\\right]^{\\\\mathsf{T}}\\\\in\\\\mathbb{R}^{D_{T}}.}\\\\end{array}\n$$  \n\nExample B.3.3 (Vector circula expansion $\\\\mathcal{V}_{\\\\mathrm{circ}})$ Let $\\\\mathbf{x}\\\\in\\\\mathbb{R}^{D_{S}}$ a vector of dimension $D_{S}$ .${\\\\bf x}_{c i r c}^{*}$ is called the circular expanded xof dimension $D_{T}$ with $D_{T}\\\\geq D_{S}$ \u2265if  \n\n$$\n\\\\begin{array}{r}{\\\\mathbf{x}_{c i r c}^{*}=\\\\mathcal{V}_{c i r c}(\\\\mathbf{x})=C o n c a t\\\\underbrace{\\\\left[\\\\mathbf{x}^{\\\\mathsf{T}},\\\\cdots,\\\\mathbf{x}^{\\\\mathsf{T}},\\\\mathbf{x}^{\\\\mathsf{T}}[\\\\colon D_{T}\\\\bmod D_{S}]\\\\right]^{\\\\mathsf{T}}\\\\in\\\\mathbb{R}^{D_{T}}}_{[D_{T}/D_{S}]}.}\\\\end{array}\n$$  \n\nExample B.3.4 (Vector random expansion $\\\\mathcal{V}_{\\\\mathrm{rand.}}$ Let $\\\\mathbf{\\\\Deltax}\\\\in\\\\mathbb{R}^{D_{S}}$ a vector of dimension $D_{S}$ .${\\\\bf x}_{r a n d}^{*}$ is called the random expanded xof dimension $D_{T}$ with $D_{T}\\\\geq D_{S}$ \u2265if  \n\n$$\n\\\\begin{array}{r}{\\\\mathbf{x}_{r a n d}^{*}=\\\\mathcal{V}_{r a n d}(\\\\mathbf{x};\\\\zeta)=C o n c a t\\\\left[\\\\underbrace{\\\\mathbf{x^{\\\\intercal}},\\\\cdots,\\\\mathbf{x^{\\\\intercal}}}_{\\\\lfloor D_{T}/D_{S}\\\\rfloor},\\\\zeta^{\\\\intercal}\\\\right]^{\\\\intercal}\\\\in\\\\mathbb{R}^{D_{T}},}\\\\end{array}\n$$  \n\nwhere $\\\\zeta\\\\in\\\\mathbb{R}^{D_{T}}$ mod $D_{S}$ is an arbitrary vector.  \n\nRemark. (1) All vector expansion examples above follow the same pattern. Specifically, when $D_{T}$ expanding from di mod s by $D_{S}$ entries differently. (2) The random vector ating $\\\\textbf{x}\\\\lfloor D_{T}/D_{S}\\\\rfloor D_{S}$ \u230a$D_{S}$ \u230b$D_{T}$ number of times. , all vector expansion methods pad first $\\\\zeta$ in vector random expansion is arbitrary, Each method deals with the remaining $\\\\lfloor D_{T}/D_{S}\\\\rfloor D_{S}$ enso $\\\\mathcal{V}_{a\\\\nu g}$ ,$\\\\mathcal{V}_{z e r o}$ ,$\\\\mathcal{V}_{c i r c}\\\\subset\\\\mathcal{V}_{r a n d}$ . (3) Here all three examples are expansion methods for vectors. In practice, neural networks like Transformers are dealing high dimensional tensors. These tensors can essentially be thought of as collections of vectors. In such scenarios, we can apply the expansion methods separately to the last dimension of these tensors.  \n\nIn the following claim, we show that vectors expanded by these operators are lossless.  \n\n$\\\\mathcal{V}_{c i r c}$ V, and vector random expansion m 1. Vector average expansio V$\\\\gamma_{r a n d}$ $\\\\mathcal{V}_{a\\\\nu g},$ are all lossless expansion for vectors. , vector zero expansion $\\\\mathcal{V}_{z e r o}$ , vector circular expansion Proof. The inverse function $\\\\mathcal{V}^{-1}:\\\\mathbb{R}^{D_{T}}\\\\rightarrow\\\\mathbb{R}^{D_{S}}$ of these vector expansion methods is  \n\n$$\n\\\\nu^{-1}({\\\\bf x})={\\\\bf x}[:D_{S}].\n$$  \n\nRemark. In practice, we want inverse mapping of expansion methods to be easily computed just like the example above.\n\n# B.4LOSSLESS EXPANSION FOR OPERATORS\nWe then give the definition of lossless expansion for operators. These operators apply on tensors, hence our definition of lossless operator expansion is based on lossless expansion in vector space. These operators can be different layers used in Transformer architectures, including LayerNorm, convolutional layers, and fully-connected layers, etc.  \n\nDefinit ansio der vector spaces $S^{i n},S^{o u t},\\\\mathcal{T}^{i n}$ and $\\\\mathcal{T}^{o u t}$ such that with $g(\\\\cdot):S^{i n}\\\\rightarrow S^{o u t}$ \u00b7$n(S^{i n})\\\\leq d i m(T^{i n})$ S\u2192S or space e T. We say the ope and dim $d i m\\\\big(S^{\\\\bar{o}u t}\\\\big)\\\\leq d i m\\\\big(T^{o u t}\\\\big)$ S$\\\\mathcal{V}_{i n}:S^{i\\\\bar{n}}\\\\to\\\\mathcal{T}^{i n}$ \u2264TEMo is $(\\\\mathcal{V}_{i n},\\\\mathcal{V}_{o u t})$ VVess output vector space expansion ppose the op -lossless for $g(\\\\cdot)$ \u00b7or is denoted if there exist $\\\\mathcal{V}_{o u t}:S^{o u t}\\\\to\\\\mathcal{T}^{o u t}$ VS\u2192T such that V$\\\\mathcal{V}_{o u t}(g(\\\\mathbf{x}))=\\\\mathcal{E}[g](\\\\mathcal{V}_{i n}(\\\\mathbf{x})),\\\\forall\\\\mathbf{x}\\\\in S^{i n}$ EV\u2200\u2208S .  \n\n$(\\\\mathcal{V}_{i n},\\\\mathcal{V}_{o u t})$ Remark. losslessly expanded input, the output of the to be invertible, we do not have restrictions on the operator expansion VV(1) Intuitively, a lossless operator -lossless for the origina $g(\\\\cdot)$ \u00b7tput. (2) For conciseness, we use \u2018 \u2019 interchangeably. (3) We only require the v Eexpanded oper pansion can be understood a $^{\\\\cdot}\\\\mathcal{E}[g]$ Eis a is $(\\\\mathcal{V}_{i n},\\\\mathcal{V}_{o u t})$ EVtor expansions .V$\\\\nu_{o u t}$ ows: when using losslessly expa -lossles V$\\\\mathcal{V}_{i n}$ and \u2018 and $\\\\mathcal{E}$ V$\\\\nu_{o u t}$ $\\\\mathcal{V}_{i n}$ ed\u300d\n", "311bf04e-2345-4be4-b40b-44f231f000ff:\u300cref_ids: 455038427552559154, chunk_ids: 6, Score: 0.3359, Text: # 5.3 LAYER NORM TUNING HAS SMALLER GRADIENT VARIANCE\nA well accepted view about LayerNorm is that, as the neural network goes deeper, the mean of LayerNorm gradients should goes to zero as the LayerNorm itself is designed to normalize all training parameters. In the meantime, the variance of LayerNorm gradients should be small to ensure a better generalization ability of the model ( Xu et al. ,2019 ) (See the proof in Appendix A.2.2 ). As we presented in fig. 4 , MLLM with LayerNorm tuning method has a more concentrated LayerNorm gradients than fine-tuning during the training process. This result gives another view on the effectiveness of LayerNorm from the optimization perspective. More visualizations are listed in Appendix A.2.2 .\n\n# 6 CONCLUSION AND DISCUSSIONS\nLayerNorm is effective and sufficient built upon MLLM pre-training. MLLM training typically involves pre-training on image-text pairs followed by finetuning on visual instruction data. While the second stage of training receives more attention, it is worth noting that the function of the first stage pre-training is non-negligible for training a competent MLLM. We have presented in the paper only a small portion of parameter activation is sufficient to tune a well-behaved MLLM. However, other models such as I NSTRUCT BLIP ( Dai et al. ,2023 ) and M INI GPT4 ( Zhu et al. ,2023 ) only tune the vision-language connector, leaving the LLM untouched during the second stage of training. These models have yielded strong performances when given a large-scale finetuning dataset. In Sec. 5.1 , we demonstrate that tuning LayerNorm may be a more effective means for the second stage training, especially when compared to existing parameter-efficient methods for training MLLMs.  \n\nLimitations. One shortcoming of these parameter-efficient finetuning methods is that they are more sensitive to hyper-parameters ( e.g ., learning rate, training epoch) than finetuning. Since the number of trainable parameters of LayerNorm is small, the model performance of LayerNorm method also varies when twitching the training hyper-parameters. This drawback calls for potential future investigations on the LayerNorm tuning method. In the Appendix A.1 , we give a hint for the grid search range of learning rate on both 7B and 13B scaled models using LayerNorm tuning based on our experimental results.  \n\nConclusion. Our studies demonstrate LayerNorm tuning as a simple yet effective tuning method for adapting LLMs comprehend multi-modal content across various model variants. Compared to LoRA tuning or full parameter finetuning, LayerNorm tuning reduces the trainable parameters by a significant $41.9\\\\%$ , enabling efficient finetuning of MLLMs on consumer-grade GPUs. Moreover, we demonstrate that MLLMs can achieve exceptional performance with minimal \u201cright\u201d data and parameters, showcasing the potential of LayerNorm tuning method in real-world applications. Given the empirical success of LayerNorm tuning, we revisited the MLLM finetuning from a domain adaptation perspective and showed that LayerNorm plays a critical role in adapting LLMs to the multi-modal domain. Additionally, our research illustrates the expressive power and optimization potential of LayerNorm tuning from layer similarities and the gradient variance. We hope that our work could inspire future works on designing improved PEFT methods that enable more diverse application scenarios for MLLMs.\n\n\n\n# A A PPENDIX\n\n# A.1 TRAINING DETAILS\nFor the first stage, we set the learning rate to 2e-3 for all variants. During the second stage, we search learning the learning rate from [2e-3, 1e-3, 6e-4, 3e-4, 1e-4, 5e-5, 2e-5, 1e-5, 6e-6, 1e-6, 1e-7] for all models and pick the best learning rate based on their performances on the CIDEr score on the Flickr $30\\\\,\\\\mathrm{k}$ task.  \n\nAccording to our tryouts based on Flickr $30\\\\,\\\\mathrm{k}$ results in Table A1 , the recommended learning rate for 7B scale is between 6e-4 to 2e-3, while on the 13B, the learning rate should be searched in the range of 3e-6 to 6e-5.  \n\nTable A1: Performance of MLLMs (LayerNorm-simp.) trained with different learning rates and scales on the Flickr30k task.   \n\n\n<html><body><table><tr><td>Learning Rate</td><td>3e-6</td><td>1e-5</td><td>3e-5</td><td>6e-5</td></tr><tr><td>MM-LLAMA2 7B</td><td>21.42</td><td>32.45</td><td>43.04</td><td>28.24</td></tr><tr><td>Learning Rate</td><td>6e-4</td><td>1e-3</td><td>2e-3</td><td></td></tr><tr><td>MM-LLAMA213B</td><td>37.35</td><td>46.88</td><td>44.15</td><td></td></tr></table></body></html>\n\n# A.2INSIGHTS OFLAYERNORMTUNING\n\n# A.2.1 VISUALIZATION EXAMPLES OF LAYER SIMILARITIES\nLower similarities between different layers of the transformer indicates more expressive power ( Pires et al. ,2023 ). In section 5.2 , we have shown the computed cosine similarity between layers on a Vicuna model, here we show the layer similarities between layers on LL A MA2 and LL A MA2 CHAT models in fig. A1 and fig. A2 . It is clear that, LayerNorm tuning again allows the model to learn dissimilar layer representations, improving the expressive power of the model.\n\n# A.2.2 GRADIENTS OF LAYER NORM\nVisualization examples of LayerNorm gradients. In fig. A3 and fig. A4 , we present the gradients of the LayerNorm parameters during the training process. Similar to the one we have shown in the main text, LayerNorm tuning demonstrates a smaller gradient variance which is important for converging to a better local minimum ( Xu et al. ,2019 ).  \n\nProof of smaller variance in LayerNorm . As stated in Sec. 5.3 , deeper the network is, the variance of LayerNorm in the model should be naturally smaller ( $\\\\mathrm{\\\\DeltaXu}$ et al. ,2019 ). We first let $\\\\mathbf{y}\\\\,=\\\\,(y_{1},y_{2},...,y_{N})$ be the normalized vector, meaning the mean and variance of $\\\\mathbf{y}$ is 0 and 1 ,respectively. We can then formulate the standard LayerNorm as follow:  \n\n$$\n{\\\\mathbf{y}}={\\\\frac{\\\\mathbf{x}-{\\\\boldsymbol{\\\\mu}}}{\\\\sigma}},\\\\quad{\\\\boldsymbol{\\\\mu}}={\\\\frac{1}{N}}\\\\sum_{i=1}^{N}x_{i},\\\\quad\\\\sigma={\\\\sqrt{{\\\\frac{1}{N}}\\\\sum_{i=1}^{N}\\\\left(x_{i}-{\\\\boldsymbol{\\\\mu}}\\\\right)^{2}}},\n$$  \n\nwhere $\\\\mathbf{x}=(x_{1},x_{2},...,x_{N})$ is the input vector and $N$ is the dimension of $\\\\mathbf{x}$ .$\\\\mu$ and $\\\\sigma$ are the mean and standard deviation of $\\\\mathbf{x}$ .  \n\nWe first define $\\\\mathbf{1}_{N}=\\\\underbrace{(1,1,...,1)^{\\\\intercal}}_{N}$ . For calculating the gradients of the normalized vector $\\\\mathbf{y}$ , we first simulate the backward propagation regarding the loss {z }$\\\\ell$ :  \n\n$$\n{\\\\frac{\\\\partial\\\\ell}{\\\\partial\\\\mathbf{x}}}=\\\\left({\\\\frac{\\\\partial\\\\mathbf{y}}{\\\\partial\\\\mathbf{x}}}+{\\\\frac{\\\\partial\\\\mu}{\\\\partial\\\\mathbf{x}}}{\\\\frac{\\\\partial\\\\mathbf{y}}{\\\\partial\\\\mu}}+{\\\\frac{\\\\partial\\\\sigma}{\\\\partial\\\\mathbf{x}}}{\\\\frac{\\\\partial\\\\mathbf{y}}{\\\\partial\\\\sigma}}\\\\right){\\\\frac{\\\\partial\\\\ell}{\\\\partial\\\\mathbf{y}}}={\\\\frac{1}{\\\\sigma}}\\\\left(I-{\\\\frac{\\\\mathbf{y}\\\\mathbf{y}^{\\\\intercal}}{N}}-{\\\\frac{\\\\mathbf{1}_{N}\\\\mathbf{1}_{N}^{\\\\intercal}}{N}}\\\\right){\\\\frac{\\\\partial\\\\ell}{\\\\partial\\\\mathbf{y}}}.\n$$  \n\n  \nFigure A1: Layer similarities between different LLM layers in (a) Finetuned and (b) LayerNormtuned MM-LL A MA2-7B.  \n\nHere we define $\\\\begin{array}{r l r}{\\\\frac{\\\\partial\\\\ell}{\\\\partial\\\\mathbf x}}&{{}\\\\!\\\\!=}&{\\\\!\\\\!(a_{1},a_{2},...,a_{N})}\\\\end{array}$ with mean $\\\\bar{a}$ and standard deviation $D_{a}$ , and $\\\\begin{array}{r l}{\\\\frac{\\\\partial\\\\ell}{\\\\partial\\\\mathbf{y}}}&{{}=}\\\\end{array}$ $(b_{1},b_{2},...,b_{N})$ with mean $\\\\bar{b}$ and standard deviation $D_{b}$ . We set $\\\\begin{array}{r}{W_{1}\\\\;=\\\\;I\\\\,-\\\\,\\\\frac{{\\\\bf y}{\\\\bf y}^{\\\\intercal}}{N}\\\\,-\\\\,\\\\frac{{\\\\bf1}_{N}{\\\\bf1}_{N}^{\\\\intercal}}{N}}\\\\end{array}$ \u2212, we can verify that:  \n\n$$\n\\\\lfloor\\\\mathbf{\\\\Pi}_{N}^{\\\\mathsf{T}}W_{1}=\\\\mathbf{1}_{N}^{\\\\mathsf{T}}{\\\\frac{1}{\\\\sigma}}\\\\left(I-{\\\\frac{\\\\mathbf{1}_{N}\\\\mathbf{1}_{N}^{\\\\mathsf{T}}+\\\\mathbf{y}\\\\mathbf{y}^{\\\\mathsf{T}}}{N}}\\\\right)={\\\\frac{1}{\\\\sigma}}\\\\left(\\\\mathbf{1}_{N}-{\\\\frac{\\\\mathbf{1}_{N}^{\\\\mathsf{T}}\\\\mathbf{1}_{N}}{N}}\\\\mathbf{1}_{N}^{\\\\mathsf{T}}-{\\\\frac{\\\\mathbf{1}_{N}^{\\\\mathsf{T}}\\\\mathbf{y}}{N}}\\\\mathbf{y}^{\\\\mathsf{T}}\\\\right)={\\\\frac{\\\\mathbf{1}_{N}-\\\\mathbf{1}_{N}-0}{\\\\sigma}}=0\n$$  \n\nTherefore, we can easily proof that $N\\\\bar{a}\\\\propto{\\\\bf1}_{N}^{\\\\top}W_{1}\\\\bar{b}=0$ , which means the mean of $\\\\frac{\\\\partial\\\\ell}{\\\\partial\\\\mathbf{x}}$ should be zero. Then we dive into proofing the variance of LayerNorm gradients should be small when the number of network parameters $N$ becomes large.  \n\n$$\n\\\\begin{array}{l}{{\\\\displaystyle{D_{a}=\\\\sum_{i=1}^{N}(a_{i}-\\\\bar{a})^{2}/N=\\\\sum_{i=1}^{N}a_{i}^{2}/N}\\\\ ~}}\\\\\\\\ {{\\\\displaystyle{=\\\\left\\\\|{(a_{1},a_{2},\\\\ldots,a_{N})^{\\\\top}}\\\\right\\\\|^{2}/N}\\\\ ~}}\\\\\\\\ {{\\\\displaystyle{=\\\\left\\\\|{W_{1}\\\\left(b_{1},b_{2},\\\\ldots,b_{N}\\\\right)^{\\\\top}}\\\\right\\\\|^{2}/N}\\\\ ~}}\\\\\\\\ {{\\\\displaystyle{=\\\\left\\\\|{W_{1}\\\\left(b_{1}-\\\\bar{b},b_{2}-\\\\bar{b},\\\\ldots,b_{N}-\\\\bar{b}\\\\right)^{\\\\top}+W_{1}\\\\bar{b}{\\\\bf1}_{N}}\\\\right\\\\|^{2}/N}\\\\ }}\\\\\\\\ {{\\\\displaystyle{=\\\\left\\\\|{W_{1}\\\\left(g_{1}-\\\\bar{b},g_{2}-\\\\bar{b},\\\\ldots,g_{N}-\\\\bar{b}\\\\right)^{\\\\top}}\\\\right\\\\|^{2}/N}\\\\ ~}}\\\\\\\\ {{\\\\displaystyle{\\\\leq W_{1}^{2}\\\\sum_{i=1}^{N}(b_{i}-\\\\bar{b})^{2}/N}\\\\ }}\\\\end{array}\n$$  \n\nSince the projection matrix $W_{1}$ is idempotent, we have $W_{1}^{2}=W_{1}$ . That is to say, when $N$ is large enough, there stands the network parameter $\\\\begin{array}{r}{D_{a}\\\\le\\\\big(I-\\\\frac{\\\\mathbf{y}\\\\mathbf{y}^{\\\\top}+\\\\mathbf{1}_{N}\\\\mathbf{1}_{N}^{\\\\top}}{N}\\\\big)\\\\sum_{i=1}^{N}(b_{i}-\\\\bar{b_{}})^{2}/N\\\\propto1/N^{2}}\\\\end{array}$ Nis large, the gradient variance of LayerNorm should be small. P\u2212. As a consequence, when  \n\n  \nFigure A2: Layer similarities between different LLM layers in (a) Finetuned and (b) LayerNormtuned MM-LL A MA2-7B CHAT .  \n\n  \nFigure A3: The gradients of both input and post LayerNorm in 21st layer of the MM-V ICUNA as the training proceeds.  \n\n  \nFigure A4: The gradients of both input and post LayerNorm in 11th layer of the MM-V ICUNA as the training proceeds.\u300d\n", "311bf04e-2345-4be4-b40b-44f231f000ff:\u300cref_ids: 454847819065993190, chunk_ids: 1, Score: 0.3184, Text: # 3.3 A TRANSFORMATION PER BLOCK\nNow that every LayerNorm in the transformer has been converted to RMSNorm, we can select any $\\\\mathbf{Q}$ to modify the model. Our initial plan was to collect signals from the model, construct an orthogonal matrix using those signals and to delete parts of the network. We quickly saw that the signals at different blocks of the network were not aligned, and that we would need to apply a different orthogonal matrix at each block, $\\\\mathbf{Q}_{\\\\ell}$ .  \n\nAllowing the orthogonal matrix used in each block to differ can be shown to leave the model unchanged using the same proof as Theorem 1 ,  \n\n  \nFigure 3: Converting a transformer network from LayerNorm to RMSNorm: the scale matrix diag $(\\\\alpha)$ is absorbed into the subsequent matrix $\\\\mathbf{W}_{\\\\mathrm{in}}$ . Figure shows the block in combined colors. We use $(\\\\alpha)$ for brevity. The mean-subtraction matrix $\\\\mathbf{M}$ is applied to each matrix $\\\\mathbf{W}_{\\\\mathrm{out}}$ . Layernorm becomes RMSNorm, up to a constant $\\\\bar{\\\\sqrt{D}}$ (not shown). Here, the scaling $(\\\\alpha^{\\\\prime})$ comes from the previous block.  \n\n  \nFigure 4: With the network converted to RMSNorm (see Figure 3 ), we apply the computational-invariance idea. The input weight matrices $\\\\mathrm{diag}(\\\\alpha)\\\\mathbf{W}_{\\\\mathrm{in}}$ are pre-multiplied by $\\\\mathbf{Q}^{\\\\top}$ . The output matrices $\\\\mathbf{W}_{\\\\mathrm{out}}\\\\mathbf{M}$ are post-multiplied by $\\\\mathbf{Q}$ . In the skip-connection, a new linear layer is added $\\\\mathbf{Q}_{\\\\ell}^{\\\\top}\\\\mathbf{Q}_{\\\\ell+1}$ . After these modifications, the matrices can be sliced (hatched areas).  \n\nwith the exception of line 5 of Algorithm 1 . Here we see that the residual connection and the output of the block must have the same rotation. To fix this, we modify the residual connection by applying the linear transformation applied to different blocks with the additional linear operation in the residual connection. Unlike the $\\\\mathbf{Q}_{\\\\ell-1}^{\\\\top}\\\\mathbf{Q}_{\\\\ell}$ \u2212to the residual. Figure 4 shows how different rotations can be modifications to the weight matrices, these additional operations cannot be pre-computed and add a small $(D\\\\times D)$ overhead to the model. Nonetheless, they are needed to allow slicing the model (Section 3.4 ) and we see real speedup overall (Section 4 ).  \n\nTo compute the matrices $\\\\mathbf{Q}_{\\\\ell}$ , we use PCA. We select a calibration dataset from the training set, run it through the model (after converting LayerNorm operations into RMSNorm), and extract the orthogonal matrix of the layer. We use the output of the transformed network to calculate the orthogonal matrices of the next layers. More precisely, if $\\\\mathbf{X}_{\\\\ell,i}$ is the output of the $\\\\ell^{\\\\mathrm{th}}$ RMSNorm block for the $i^{\\\\mathrm{th}}$ sequence in the calibration dataset, we compute  \n\n$$\n\\\\mathbf{C}_{\\\\ell}=\\\\sum_{i}\\\\mathbf{X}_{\\\\ell,i}^{\\\\top}\\\\mathbf{X}_{\\\\ell,i}\n$$  \n\nand set $\\\\mathbf{Q}_{\\\\ell}$ to the be the eigenvectors of $\\\\mathbf{C}_{\\\\ell}$ , sorted by decreasing eigenvalues.\n\n# 3.4 SLICING\nThe goal of Principal Component Analysis is usually to take a data matrix $\\\\mathbf{X}$ and compute a lower dimensional representation $\\\\mathbf{Z}$ , and an approximate reconstruction $\\\\tilde{\\\\mathbf{X}}$ :  \n\n$$\n\\\\mathbf{Z}=\\\\mathbf{X}\\\\mathbf{Q}\\\\mathbf{D}\\\\,,\\\\qquad\\\\tilde{\\\\mathbf{X}}=\\\\mathbf{Z}\\\\mathbf{D}^{\\\\top}\\\\mathbf{Q}^{\\\\top}\\\\,.\n$$  \n\nwhere $\\\\mathbf{Q}$ is the ectors of ${\\\\bf X}^{\\\\top}{\\\\bf X}$ , and $\\\\mathbf{D}$ is a $D\\\\times D_{\\\\mathrm{small}}$ deletion matrix (containing $D_{\\\\mathrm{small}}$ The reconstruction is columns of the $D\\\\times D$ \u00d7$L_{2}$ identity matrix), which removes some of the columns of the matrix to the left. optimal, in the sense that QD is a linear mapping that minimizes $\\\\lVert\\\\mathbf{X}-\\\\tilde{\\\\mathbf{X}}\\\\rVert^{2}$ .  \n\nWhen we apply PCA to the signal matrix $\\\\mathbf{X}$ bween blocks, we never materialize the $N\\\\times D$ signal matrix, but we apply the deletion matrix Dto the operations preceding and succeeding the construction of that matrix, which have already been multiplied by $\\\\mathbf{Q}$ in the above. We delete rows of $\\\\mathbf{W}_{\\\\mathrm{in}}$ that we have inserted into the residual connection (see Figure and columns of $\\\\mathbf{W}_{\\\\mathrm{out}}$ and $\\\\mathbf{W}_{\\\\mathrm{embd}}$ . We also delete both rows 4 ). and columns of the matrix $\\\\mathbf{Q}_{\\\\ell-1}^{\\\\top}\\\\mathbf{Q}_{\\\\ell}$ \u2212\n\n# 4 EXPERIMENTAL VALIDATION\nSetup We use HuggingFace Transformers ( Wolf et al. ,2019 ) to implement our code with PyTorch (Paszke et al. ,2019 ). The computation of $\\\\mathbf{Q}$ is performed on a single H100 GPU with 80GB of memory, taking approximately 3.5 hours to complete for the L LAMA -2 70B model. During the PCA calculation, we use double precision for computing the eigenvectors of the covariance matrix. We find that using single precision for eigenvector calculations in PyTorch leads to a discrepancy in the final accuracy, as detailed in Appendix A.2 .  \n\nWe experiment with two different calibration sets: 1024 samples from the WikiText-2 training dataset ( Merity et al. ,2016 ) and 5000 samples from the Alpaca training dataset ( Taori et al. ,2023 ). Sequence lengths are chosen as the maximum of each language model. An ablation study on the calibration set size and sequence length is presented in Appendix A.3 .  \n\nModels, Tasks, and GPUs We evaluate all our experiments on OPT ( Zhang et al. ,2022 ), L LAMA -2 (Touvron et al. ,2023 ) model families, and additionally evaluate Phi-2 (in our zero-shot task) experiments. We exclude OPT 175B, as it is outperformed by smaller L LAMA -2 models. Nonetheless, we anticipate that this larger model will yield improved results, as larger models typically offer more promising opportunities for compression (see Section 4.1 ). We evaluate our scheme on both language generation as well as popular zero-shot tasks. To demonstrate the comprehensive speedup achieved by SliceGPT we use: Quadro RTX6000 GPUs with 24GB of memory as a representative example of consumer-level GPUs; 40GB A100s and 80GB H100s to provide datacenter-level benchmarks.  \n\nBaseline Setup We initially planned to compare our results against a scheme that pruned columns (or rows) with the smallest norm but found that this baseline was very poor, with the perplexity of the model soaring into the 1000s after pruning just a few columns. Instead, we compare SliceGPT against SparseGPT ( Frantar & Alistarh ,2023 ) employing a 2:4 sparsity ratio, as this is the only sparsity scheme which achieves speedup ( Mishra et al. ,2021 ).\u300d\n"]}}, "__type__": "1"}}, "template_store/metadata": {"34a0d1c6-e1a9-4362-9494-6ff2720dd687": {"template_hash": ""}}}