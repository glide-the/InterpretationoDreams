角色,内容,分镜
311bf04e-2345-4be4-b40b-44f231f000ff,稳定性,4>1
311bf04e-2345-4be4-b40b-44f231f000ff,"### 问题

在大模型的训练过程中，LayerNorm和RMSNorm在复杂、动态环境下的稳定性表现如何？具体来说，在对抗训练或鲁棒优化等场景中，这两种归一化方法的表现有何差异？哪种方法更能有效应对动态环境中的挑战，并保持模型的稳定性？",4>1
311bf04e-2345-4be4-b40b-44f231f000ff,"ref_ids: 454846008172788376, chunk_ids: 4, Score: 0.4043, Text: # B.2 MODEL LAYERS
In this section, we give the formal definition of LayerNorm $\\operatorname{LN}(\\cdot)$ and RMS Norm ${\\mathrm{RMS}}\\left(\\cdot\\right)$ .  

Definition 1 (LayerNorm) .LayerNorm $L N(\\cdot;\\mu,\\beta,\\epsilon)$ of dimension $D$ is defined as:  

$$
L N(\\mathbf{x};\\pmb{\\mu},\\beta,\\epsilon)=\\frac{\\mathbf{x}-\\mathbb{E}[\\mathbf{x}]}{\\sqrt{\\mathrm{Var}[\\mathbf{x}]+\\epsilon}}\\odot\\pmb{\\mu}+\\beta,
$$  

where $\\mathbf{x},\\pmb{\\mu},\\beta\\in\\mathbb{R}^{D}$ .  

Definition 2 (RMSNorm) .RMS Norm $R M S(\\cdot;\\mu,\\epsilon)$ of dimension $D$ is defined as:  

$$
R M S(\\mathbf{x};\\pmb{\\mu},\\epsilon)=\\frac{\\mathbf{x}}{\\sqrt{\\frac{1}{D}\\sum_{i=1}^{D}(\\mathbf{x}[i])^{2}+\\epsilon}}\\odot\\pmb{\\mu},
$$  

where x,$\\pmb{\\mu}\\in\\mathbb{R}^{D}$ .  

Remark. In neural networks, inputs of normalization layers are usually high dimension tensors. In this case, LayerNorm and RMSNorm normally apply to the last dimension separately.

# B.3 LOSSLESS EXPANSION IN VECTOR SPACE
In this section, we first give the general definition of lossless expansion in vector space.  

dimensions satisfy dim it is invertible. Definition 3 (Lossless $(\\bar{\\mathcal{T}})\\geq d i m(S)$ T≥S, a vector space expansion ector space) .Given $\\boldsymbol{S}$ and V$\\tau$ $\\mathcal{V}:\\mathcal{S}\\rightarrow\\mathcal{T}$ S →T is said to be lossless if ector spaces where the  

Remark. Note that the identity function Id is lossless with its inverse being itself.  

Then we give a few examples of lossless vector space expansions. These examples will also be used in LEMON.  

Example B.3.1 (Vector average expansion $\\mathcal{V}_{\\mathrm{avg.}}$ ).Let $\\mathbf{\\widetilde{x}}\\in\\mathbb{R}^{D_{S}}$ be a vector of dimension $D_{S}$ and its average $\\begin{array}{r}{\\lambda_{V}g(\\mathbf{x})=\\mathbb{E}[\\mathbf{x}]=\\frac{1}{D_{S}}\\sum_{i}^{D_{S}}\\mathbf{x}[i]}\\end{array}$ P].$\\mathbf{x}_{a\\nu g}^{*}$ is called the average expanded xof dimension $D_{T}$  

with $D_{T}\\geq D_{S}$ if  

$$
\\mathbf{x}_{a v g}^{*}=\\mathcal{V}_{a v g}(\\mathbf{x})=C o n c a t\\left[\\underbrace{\\mathbf{x}^{\\mathsf{T}},\\cdots,\\mathbf{x}^{\\mathsf{T}}}_{\\lfloor D_{T}/D s\\rfloor},\\underbrace{A v g(\\mathbf{x}),\\cdots,A v g(\\mathbf{x})}_{D_{T}\\mathrm{~mod~}D_{S}}\\right]^{\\mathsf{T}}\\in\\mathbb{R}^{D_{T}}.
$$  

Example B.3.2 (Vector z o expansion $\\mathcal{V}_{\\mathrm{zero.}}$ ).Le $\\mathbf{x}\\in\\mathbb{R}^{D_{S}}$ be a vector of dimension $D_{S}$ .$\\mathbf{x}_{z e r o}^{*}$ is called the zero expanded xof dimension $D_{T}$ with $D_{T}\\geq D_{S}$ ≥if  

$$
\\begin{array}{r}{\\mathbf{x}_{z e r o}^{*}=\\mathcal{V}_{z e r o}(\\mathbf{x})=C o n c a t\\left[\\underbrace{\\mathbf{x^{\\mathsf{T}}},\\cdots,\\mathbf{x^{\\mathsf{T}}}}_{\\lfloor D_{T}/D_{S}\\rfloor},\\underbrace{0,\\cdots,0}_{D_{T}\\mathrm{~mod~}D_{S}}\\right]^{\\mathsf{T}}\\in\\mathbb{R}^{D_{T}}.}\\end{array}
$$  

Example B.3.3 (Vector circula expansion $\\mathcal{V}_{\\mathrm{circ}})$ Let $\\mathbf{x}\\in\\mathbb{R}^{D_{S}}$ a vector of dimension $D_{S}$ .${\\bf x}_{c i r c}^{*}$ is called the circular expanded xof dimension $D_{T}$ with $D_{T}\\geq D_{S}$ ≥if  

$$
\\begin{array}{r}{\\mathbf{x}_{c i r c}^{*}=\\mathcal{V}_{c i r c}(\\mathbf{x})=C o n c a t\\underbrace{\\left[\\mathbf{x}^{\\mathsf{T}},\\cdots,\\mathbf{x}^{\\mathsf{T}},\\mathbf{x}^{\\mathsf{T}}[\\colon D_{T}\\bmod D_{S}]\\right]^{\\mathsf{T}}\\in\\mathbb{R}^{D_{T}}}_{[D_{T}/D_{S}]}.}\\end{array}
$$  

Example B.3.4 (Vector random expansion $\\mathcal{V}_{\\mathrm{rand.}}$ Let $\\mathbf{\\Deltax}\\in\\mathbb{R}^{D_{S}}$ a vector of dimension $D_{S}$ .${\\bf x}_{r a n d}^{*}$ is called the random expanded xof dimension $D_{T}$ with $D_{T}\\geq D_{S}$ ≥if  

$$
\\begin{array}{r}{\\mathbf{x}_{r a n d}^{*}=\\mathcal{V}_{r a n d}(\\mathbf{x};\\zeta)=C o n c a t\\left[\\underbrace{\\mathbf{x^{\\intercal}},\\cdots,\\mathbf{x^{\\intercal}}}_{\\lfloor D_{T}/D_{S}\\rfloor},\\zeta^{\\intercal}\\right]^{\\intercal}\\in\\mathbb{R}^{D_{T}},}\\end{array}
$$  

where $\\zeta\\in\\mathbb{R}^{D_{T}}$ mod $D_{S}$ is an arbitrary vector.  

Remark. (1) All vector expansion examples above follow the same pattern. Specifically, when $D_{T}$ expanding from di mod s by $D_{S}$ entries differently. (2) The random vector ating $\\textbf{x}\\lfloor D_{T}/D_{S}\\rfloor D_{S}$ ⌊$D_{S}$ ⌋$D_{T}$ number of times. , all vector expansion methods pad first $\\zeta$ in vector random expansion is arbitrary, Each method deals with the remaining $\\lfloor D_{T}/D_{S}\\rfloor D_{S}$ enso $\\mathcal{V}_{a\\nu g}$ ,$\\mathcal{V}_{z e r o}$ ,$\\mathcal{V}_{c i r c}\\subset\\mathcal{V}_{r a n d}$ . (3) Here all three examples are expansion methods for vectors. In practice, neural networks like Transformers are dealing high dimensional tensors. These tensors can essentially be thought of as collections of vectors. In such scenarios, we can apply the expansion methods separately to the last dimension of these tensors.  

In the following claim, we show that vectors expanded by these operators are lossless.  

$\\mathcal{V}_{c i r c}$ V, and vector random expansion m 1. Vector average expansio V$\\gamma_{r a n d}$ $\\mathcal{V}_{a\\nu g},$ are all lossless expansion for vectors. , vector zero expansion $\\mathcal{V}_{z e r o}$ , vector circular expansion Proof. The inverse function $\\mathcal{V}^{-1}:\\mathbb{R}^{D_{T}}\\rightarrow\\mathbb{R}^{D_{S}}$ of these vector expansion methods is  

$$
\\nu^{-1}({\\bf x})={\\bf x}[:D_{S}].
$$  

Remark. In practice, we want inverse mapping of expansion methods to be easily computed just like the example above.

# B.4LOSSLESS EXPANSION FOR OPERATORS
We then give the definition of lossless expansion for operators. These operators apply on tensors, hence our definition of lossless operator expansion is based on lossless expansion in vector space. These operators can be different layers used in Transformer architectures, including LayerNorm, convolutional layers, and fully-connected layers, etc.  

Definit ansio der vector spaces $S^{i n},S^{o u t},\\mathcal{T}^{i n}$ and $\\mathcal{T}^{o u t}$ such that with $g(\\cdot):S^{i n}\\rightarrow S^{o u t}$ ·$n(S^{i n})\\leq d i m(T^{i n})$ S→S or space e T. We say the ope and dim $d i m\\big(S^{\\bar{o}u t}\\big)\\leq d i m\\big(T^{o u t}\\big)$ S$\\mathcal{V}_{i n}:S^{i\\bar{n}}\\to\\mathcal{T}^{i n}$ ≤TEMo is $(\\mathcal{V}_{i n},\\mathcal{V}_{o u t})$ VVess output vector space expansion ppose the op -lossless for $g(\\cdot)$ ·or is denoted if there exist $\\mathcal{V}_{o u t}:S^{o u t}\\to\\mathcal{T}^{o u t}$ VS→T such that V$\\mathcal{V}_{o u t}(g(\\mathbf{x}))=\\mathcal{E}[g](\\mathcal{V}_{i n}(\\mathbf{x})),\\forall\\mathbf{x}\\in S^{i n}$ EV∀∈S .  

$(\\mathcal{V}_{i n},\\mathcal{V}_{o u t})$ Remark. losslessly expanded input, the output of the to be invertible, we do not have restrictions on the operator expansion VV(1) Intuitively, a lossless operator -lossless for the origina $g(\\cdot)$ ·tput. (2) For conciseness, we use ‘ ’ interchangeably. (3) We only require the v Eexpanded oper pansion can be understood a $^{\\cdot}\\mathcal{E}[g]$ Eis a is $(\\mathcal{V}_{i n},\\mathcal{V}_{o u t})$ EVtor expansions .V$\\nu_{o u t}$ ows: when using losslessly expa -lossles V$\\mathcal{V}_{i n}$ and ‘ and $\\mathcal{E}$ V$\\nu_{o u t}$ $\\mathcal{V}_{i n}$ ed",4>1
311bf04e-2345-4be4-b40b-44f231f000ff,"ref_ids: 455038427552559154, chunk_ids: 6, Score: 0.3359, Text: # 5.3 LAYER NORM TUNING HAS SMALLER GRADIENT VARIANCE
A well accepted view about LayerNorm is that, as the neural network goes deeper, the mean of LayerNorm gradients should goes to zero as the LayerNorm itself is designed to normalize all training parameters. In the meantime, the variance of LayerNorm gradients should be small to ensure a better generalization ability of the model ( Xu et al. ,2019 ) (See the proof in Appendix A.2.2 ). As we presented in fig. 4 , MLLM with LayerNorm tuning method has a more concentrated LayerNorm gradients than fine-tuning during the training process. This result gives another view on the effectiveness of LayerNorm from the optimization perspective. More visualizations are listed in Appendix A.2.2 .

# 6 CONCLUSION AND DISCUSSIONS
LayerNorm is effective and sufficient built upon MLLM pre-training. MLLM training typically involves pre-training on image-text pairs followed by finetuning on visual instruction data. While the second stage of training receives more attention, it is worth noting that the function of the first stage pre-training is non-negligible for training a competent MLLM. We have presented in the paper only a small portion of parameter activation is sufficient to tune a well-behaved MLLM. However, other models such as I NSTRUCT BLIP ( Dai et al. ,2023 ) and M INI GPT4 ( Zhu et al. ,2023 ) only tune the vision-language connector, leaving the LLM untouched during the second stage of training. These models have yielded strong performances when given a large-scale finetuning dataset. In Sec. 5.1 , we demonstrate that tuning LayerNorm may be a more effective means for the second stage training, especially when compared to existing parameter-efficient methods for training MLLMs.  

Limitations. One shortcoming of these parameter-efficient finetuning methods is that they are more sensitive to hyper-parameters ( e.g ., learning rate, training epoch) than finetuning. Since the number of trainable parameters of LayerNorm is small, the model performance of LayerNorm method also varies when twitching the training hyper-parameters. This drawback calls for potential future investigations on the LayerNorm tuning method. In the Appendix A.1 , we give a hint for the grid search range of learning rate on both 7B and 13B scaled models using LayerNorm tuning based on our experimental results.  

Conclusion. Our studies demonstrate LayerNorm tuning as a simple yet effective tuning method for adapting LLMs comprehend multi-modal content across various model variants. Compared to LoRA tuning or full parameter finetuning, LayerNorm tuning reduces the trainable parameters by a significant $41.9\\%$ , enabling efficient finetuning of MLLMs on consumer-grade GPUs. Moreover, we demonstrate that MLLMs can achieve exceptional performance with minimal “right” data and parameters, showcasing the potential of LayerNorm tuning method in real-world applications. Given the empirical success of LayerNorm tuning, we revisited the MLLM finetuning from a domain adaptation perspective and showed that LayerNorm plays a critical role in adapting LLMs to the multi-modal domain. Additionally, our research illustrates the expressive power and optimization potential of LayerNorm tuning from layer similarities and the gradient variance. We hope that our work could inspire future works on designing improved PEFT methods that enable more diverse application scenarios for MLLMs.



# A A PPENDIX

# A.1 TRAINING DETAILS
For the first stage, we set the learning rate to 2e-3 for all variants. During the second stage, we search learning the learning rate from [2e-3, 1e-3, 6e-4, 3e-4, 1e-4, 5e-5, 2e-5, 1e-5, 6e-6, 1e-6, 1e-7] for all models and pick the best learning rate based on their performances on the CIDEr score on the Flickr $30\\,\\mathrm{k}$ task.  

According to our tryouts based on Flickr $30\\,\\mathrm{k}$ results in Table A1 , the recommended learning rate for 7B scale is between 6e-4 to 2e-3, while on the 13B, the learning rate should be searched in the range of 3e-6 to 6e-5.  

Table A1: Performance of MLLMs (LayerNorm-simp.) trained with different learning rates and scales on the Flickr30k task.   


<html><body><table><tr><td>Learning Rate</td><td>3e-6</td><td>1e-5</td><td>3e-5</td><td>6e-5</td></tr><tr><td>MM-LLAMA2 7B</td><td>21.42</td><td>32.45</td><td>43.04</td><td>28.24</td></tr><tr><td>Learning Rate</td><td>6e-4</td><td>1e-3</td><td>2e-3</td><td></td></tr><tr><td>MM-LLAMA213B</td><td>37.35</td><td>46.88</td><td>44.15</td><td></td></tr></table></body></html>

# A.2INSIGHTS OFLAYERNORMTUNING

# A.2.1 VISUALIZATION EXAMPLES OF LAYER SIMILARITIES
Lower similarities between different layers of the transformer indicates more expressive power ( Pires et al. ,2023 ). In section 5.2 , we have shown the computed cosine similarity between layers on a Vicuna model, here we show the layer similarities between layers on LL A MA2 and LL A MA2 CHAT models in fig. A1 and fig. A2 . It is clear that, LayerNorm tuning again allows the model to learn dissimilar layer representations, improving the expressive power of the model.

# A.2.2 GRADIENTS OF LAYER NORM
Visualization examples of LayerNorm gradients. In fig. A3 and fig. A4 , we present the gradients of the LayerNorm parameters during the training process. Similar to the one we have shown in the main text, LayerNorm tuning demonstrates a smaller gradient variance which is important for converging to a better local minimum ( Xu et al. ,2019 ).  

Proof of smaller variance in LayerNorm . As stated in Sec. 5.3 , deeper the network is, the variance of LayerNorm in the model should be naturally smaller ( $\\mathrm{\\DeltaXu}$ et al. ,2019 ). We first let $\\mathbf{y}\\,=\\,(y_{1},y_{2},...,y_{N})$ be the normalized vector, meaning the mean and variance of $\\mathbf{y}$ is 0 and 1 ,respectively. We can then formulate the standard LayerNorm as follow:  

$$
{\\mathbf{y}}={\\frac{\\mathbf{x}-{\\boldsymbol{\\mu}}}{\\sigma}},\\quad{\\boldsymbol{\\mu}}={\\frac{1}{N}}\\sum_{i=1}^{N}x_{i},\\quad\\sigma={\\sqrt{{\\frac{1}{N}}\\sum_{i=1}^{N}\\left(x_{i}-{\\boldsymbol{\\mu}}\\right)^{2}}},
$$  

where $\\mathbf{x}=(x_{1},x_{2},...,x_{N})$ is the input vector and $N$ is the dimension of $\\mathbf{x}$ .$\\mu$ and $\\sigma$ are the mean and standard deviation of $\\mathbf{x}$ .  

We first define $\\mathbf{1}_{N}=\\underbrace{(1,1,...,1)^{\\intercal}}_{N}$ . For calculating the gradients of the normalized vector $\\mathbf{y}$ , we first simulate the backward propagation regarding the loss {z }$\\ell$ :  

$$
{\\frac{\\partial\\ell}{\\partial\\mathbf{x}}}=\\left({\\frac{\\partial\\mathbf{y}}{\\partial\\mathbf{x}}}+{\\frac{\\partial\\mu}{\\partial\\mathbf{x}}}{\\frac{\\partial\\mathbf{y}}{\\partial\\mu}}+{\\frac{\\partial\\sigma}{\\partial\\mathbf{x}}}{\\frac{\\partial\\mathbf{y}}{\\partial\\sigma}}\\right){\\frac{\\partial\\ell}{\\partial\\mathbf{y}}}={\\frac{1}{\\sigma}}\\left(I-{\\frac{\\mathbf{y}\\mathbf{y}^{\\intercal}}{N}}-{\\frac{\\mathbf{1}_{N}\\mathbf{1}_{N}^{\\intercal}}{N}}\\right){\\frac{\\partial\\ell}{\\partial\\mathbf{y}}}.
$$  

  
Figure A1: Layer similarities between different LLM layers in (a) Finetuned and (b) LayerNormtuned MM-LL A MA2-7B.  

Here we define $\\begin{array}{r l r}{\\frac{\\partial\\ell}{\\partial\\mathbf x}}&{{}\\!\\!=}&{\\!\\!(a_{1},a_{2},...,a_{N})}\\end{array}$ with mean $\\bar{a}$ and standard deviation $D_{a}$ , and $\\begin{array}{r l}{\\frac{\\partial\\ell}{\\partial\\mathbf{y}}}&{{}=}\\end{array}$ $(b_{1},b_{2},...,b_{N})$ with mean $\\bar{b}$ and standard deviation $D_{b}$ . We set $\\begin{array}{r}{W_{1}\\;=\\;I\\,-\\,\\frac{{\\bf y}{\\bf y}^{\\intercal}}{N}\\,-\\,\\frac{{\\bf1}_{N}{\\bf1}_{N}^{\\intercal}}{N}}\\end{array}$ −, we can verify that:  

$$
\\lfloor\\mathbf{\\Pi}_{N}^{\\mathsf{T}}W_{1}=\\mathbf{1}_{N}^{\\mathsf{T}}{\\frac{1}{\\sigma}}\\left(I-{\\frac{\\mathbf{1}_{N}\\mathbf{1}_{N}^{\\mathsf{T}}+\\mathbf{y}\\mathbf{y}^{\\mathsf{T}}}{N}}\\right)={\\frac{1}{\\sigma}}\\left(\\mathbf{1}_{N}-{\\frac{\\mathbf{1}_{N}^{\\mathsf{T}}\\mathbf{1}_{N}}{N}}\\mathbf{1}_{N}^{\\mathsf{T}}-{\\frac{\\mathbf{1}_{N}^{\\mathsf{T}}\\mathbf{y}}{N}}\\mathbf{y}^{\\mathsf{T}}\\right)={\\frac{\\mathbf{1}_{N}-\\mathbf{1}_{N}-0}{\\sigma}}=0
$$  

Therefore, we can easily proof that $N\\bar{a}\\propto{\\bf1}_{N}^{\\top}W_{1}\\bar{b}=0$ , which means the mean of $\\frac{\\partial\\ell}{\\partial\\mathbf{x}}$ should be zero. Then we dive into proofing the variance of LayerNorm gradients should be small when the number of network parameters $N$ becomes large.  

$$
\\begin{array}{l}{{\\displaystyle{D_{a}=\\sum_{i=1}^{N}(a_{i}-\\bar{a})^{2}/N=\\sum_{i=1}^{N}a_{i}^{2}/N}\\ ~}}\\\\ {{\\displaystyle{=\\left\\|{(a_{1},a_{2},\\ldots,a_{N})^{\\top}}\\right\\|^{2}/N}\\ ~}}\\\\ {{\\displaystyle{=\\left\\|{W_{1}\\left(b_{1},b_{2},\\ldots,b_{N}\\right)^{\\top}}\\right\\|^{2}/N}\\ ~}}\\\\ {{\\displaystyle{=\\left\\|{W_{1}\\left(b_{1}-\\bar{b},b_{2}-\\bar{b},\\ldots,b_{N}-\\bar{b}\\right)^{\\top}+W_{1}\\bar{b}{\\bf1}_{N}}\\right\\|^{2}/N}\\ }}\\\\ {{\\displaystyle{=\\left\\|{W_{1}\\left(g_{1}-\\bar{b},g_{2}-\\bar{b},\\ldots,g_{N}-\\bar{b}\\right)^{\\top}}\\right\\|^{2}/N}\\ ~}}\\\\ {{\\displaystyle{\\leq W_{1}^{2}\\sum_{i=1}^{N}(b_{i}-\\bar{b})^{2}/N}\\ }}\\end{array}
$$  

Since the projection matrix $W_{1}$ is idempotent, we have $W_{1}^{2}=W_{1}$ . That is to say, when $N$ is large enough, there stands the network parameter $\\begin{array}{r}{D_{a}\\le\\big(I-\\frac{\\mathbf{y}\\mathbf{y}^{\\top}+\\mathbf{1}_{N}\\mathbf{1}_{N}^{\\top}}{N}\\big)\\sum_{i=1}^{N}(b_{i}-\\bar{b_{}})^{2}/N\\propto1/N^{2}}\\end{array}$ Nis large, the gradient variance of LayerNorm should be small. P−. As a consequence, when  

  
Figure A2: Layer similarities between different LLM layers in (a) Finetuned and (b) LayerNormtuned MM-LL A MA2-7B CHAT .  

  
Figure A3: The gradients of both input and post LayerNorm in 21st layer of the MM-V ICUNA as the training proceeds.  

  
Figure A4: The gradients of both input and post LayerNorm in 11th layer of the MM-V ICUNA as the training proceeds.",4>1
311bf04e-2345-4be4-b40b-44f231f000ff,"ref_ids: 454847819065993190, chunk_ids: 1, Score: 0.3184, Text: # 3.3 A TRANSFORMATION PER BLOCK
Now that every LayerNorm in the transformer has been converted to RMSNorm, we can select any $\\mathbf{Q}$ to modify the model. Our initial plan was to collect signals from the model, construct an orthogonal matrix using those signals and to delete parts of the network. We quickly saw that the signals at different blocks of the network were not aligned, and that we would need to apply a different orthogonal matrix at each block, $\\mathbf{Q}_{\\ell}$ .  

Allowing the orthogonal matrix used in each block to differ can be shown to leave the model unchanged using the same proof as Theorem 1 ,  

  
Figure 3: Converting a transformer network from LayerNorm to RMSNorm: the scale matrix diag $(\\alpha)$ is absorbed into the subsequent matrix $\\mathbf{W}_{\\mathrm{in}}$ . Figure shows the block in combined colors. We use $(\\alpha)$ for brevity. The mean-subtraction matrix $\\mathbf{M}$ is applied to each matrix $\\mathbf{W}_{\\mathrm{out}}$ . Layernorm becomes RMSNorm, up to a constant $\\bar{\\sqrt{D}}$ (not shown). Here, the scaling $(\\alpha^{\\prime})$ comes from the previous block.  

  
Figure 4: With the network converted to RMSNorm (see Figure 3 ), we apply the computational-invariance idea. The input weight matrices $\\mathrm{diag}(\\alpha)\\mathbf{W}_{\\mathrm{in}}$ are pre-multiplied by $\\mathbf{Q}^{\\top}$ . The output matrices $\\mathbf{W}_{\\mathrm{out}}\\mathbf{M}$ are post-multiplied by $\\mathbf{Q}$ . In the skip-connection, a new linear layer is added $\\mathbf{Q}_{\\ell}^{\\top}\\mathbf{Q}_{\\ell+1}$ . After these modifications, the matrices can be sliced (hatched areas).  

with the exception of line 5 of Algorithm 1 . Here we see that the residual connection and the output of the block must have the same rotation. To fix this, we modify the residual connection by applying the linear transformation applied to different blocks with the additional linear operation in the residual connection. Unlike the $\\mathbf{Q}_{\\ell-1}^{\\top}\\mathbf{Q}_{\\ell}$ −to the residual. Figure 4 shows how different rotations can be modifications to the weight matrices, these additional operations cannot be pre-computed and add a small $(D\\times D)$ overhead to the model. Nonetheless, they are needed to allow slicing the model (Section 3.4 ) and we see real speedup overall (Section 4 ).  

To compute the matrices $\\mathbf{Q}_{\\ell}$ , we use PCA. We select a calibration dataset from the training set, run it through the model (after converting LayerNorm operations into RMSNorm), and extract the orthogonal matrix of the layer. We use the output of the transformed network to calculate the orthogonal matrices of the next layers. More precisely, if $\\mathbf{X}_{\\ell,i}$ is the output of the $\\ell^{\\mathrm{th}}$ RMSNorm block for the $i^{\\mathrm{th}}$ sequence in the calibration dataset, we compute  

$$
\\mathbf{C}_{\\ell}=\\sum_{i}\\mathbf{X}_{\\ell,i}^{\\top}\\mathbf{X}_{\\ell,i}
$$  

and set $\\mathbf{Q}_{\\ell}$ to the be the eigenvectors of $\\mathbf{C}_{\\ell}$ , sorted by decreasing eigenvalues.

# 3.4 SLICING
The goal of Principal Component Analysis is usually to take a data matrix $\\mathbf{X}$ and compute a lower dimensional representation $\\mathbf{Z}$ , and an approximate reconstruction $\\tilde{\\mathbf{X}}$ :  

$$
\\mathbf{Z}=\\mathbf{X}\\mathbf{Q}\\mathbf{D}\\,,\\qquad\\tilde{\\mathbf{X}}=\\mathbf{Z}\\mathbf{D}^{\\top}\\mathbf{Q}^{\\top}\\,.
$$  

where $\\mathbf{Q}$ is the ectors of ${\\bf X}^{\\top}{\\bf X}$ , and $\\mathbf{D}$ is a $D\\times D_{\\mathrm{small}}$ deletion matrix (containing $D_{\\mathrm{small}}$ The reconstruction is columns of the $D\\times D$ ×$L_{2}$ identity matrix), which removes some of the columns of the matrix to the left. optimal, in the sense that QD is a linear mapping that minimizes $\\lVert\\mathbf{X}-\\tilde{\\mathbf{X}}\\rVert^{2}$ .  

When we apply PCA to the signal matrix $\\mathbf{X}$ bween blocks, we never materialize the $N\\times D$ signal matrix, but we apply the deletion matrix Dto the operations preceding and succeeding the construction of that matrix, which have already been multiplied by $\\mathbf{Q}$ in the above. We delete rows of $\\mathbf{W}_{\\mathrm{in}}$ that we have inserted into the residual connection (see Figure and columns of $\\mathbf{W}_{\\mathrm{out}}$ and $\\mathbf{W}_{\\mathrm{embd}}$ . We also delete both rows 4 ). and columns of the matrix $\\mathbf{Q}_{\\ell-1}^{\\top}\\mathbf{Q}_{\\ell}$ −

# 4 EXPERIMENTAL VALIDATION
Setup We use HuggingFace Transformers ( Wolf et al. ,2019 ) to implement our code with PyTorch (Paszke et al. ,2019 ). The computation of $\\mathbf{Q}$ is performed on a single H100 GPU with 80GB of memory, taking approximately 3.5 hours to complete for the L LAMA -2 70B model. During the PCA calculation, we use double precision for computing the eigenvectors of the covariance matrix. We find that using single precision for eigenvector calculations in PyTorch leads to a discrepancy in the final accuracy, as detailed in Appendix A.2 .  

We experiment with two different calibration sets: 1024 samples from the WikiText-2 training dataset ( Merity et al. ,2016 ) and 5000 samples from the Alpaca training dataset ( Taori et al. ,2023 ). Sequence lengths are chosen as the maximum of each language model. An ablation study on the calibration set size and sequence length is presented in Appendix A.3 .  

Models, Tasks, and GPUs We evaluate all our experiments on OPT ( Zhang et al. ,2022 ), L LAMA -2 (Touvron et al. ,2023 ) model families, and additionally evaluate Phi-2 (in our zero-shot task) experiments. We exclude OPT 175B, as it is outperformed by smaller L LAMA -2 models. Nonetheless, we anticipate that this larger model will yield improved results, as larger models typically offer more promising opportunities for compression (see Section 4.1 ). We evaluate our scheme on both language generation as well as popular zero-shot tasks. To demonstrate the comprehensive speedup achieved by SliceGPT we use: Quadro RTX6000 GPUs with 24GB of memory as a representative example of consumer-level GPUs; 40GB A100s and 80GB H100s to provide datacenter-level benchmarks.  

Baseline Setup We initially planned to compare our results against a scheme that pruned columns (or rows) with the smallest norm but found that this baseline was very poor, with the perplexity of the model soaring into the 1000s after pruning just a few columns. Instead, we compare SliceGPT against SparseGPT ( Frantar & Alistarh ,2023 ) employing a 2:4 sparsity ratio, as this is the only sparsity scheme which achieves speedup ( Mishra et al. ,2021 ).",4>1
