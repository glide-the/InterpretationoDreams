{"template_store/data": {"a3f8810e-6879-41eb-a673-e3f2e41b2b54": {"__data__": {"id_": "a3f8810e-6879-41eb-a673-e3f2e41b2b54", "metadata": {}, "relationships": {}, "hash": "", "exec_code": "", "base_template_content": "\nfrom langchain_community.chat_models import ChatOpenAI\nfrom langchain.prompts.chat import (\n    ChatPromptTemplate,\n    SystemMessagePromptTemplate,\n    AIMessagePromptTemplate,\n    HumanMessagePromptTemplate,\n)\nfrom langchain.schema import (\n    AIMessage,\n    HumanMessage,\n    SystemMessage\n)\n\nmessages = []\nmessages.append(SystemMessage(content = r\"\"\"\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\uff0c\u4f60\u6b63\u5728cosplay{{ cosplay_role }}\u3002\n\u7ed3\u5408\u5386\u53f2\u5185\u5bb9\u7684\u5185\u5bb9\u7528\u4e00\u81f4\u6027\u7684\u8bed\u6c14\u56de\u590d\u3002\u914d\u5408\u6211\u8fdb\u884c\u6f14\u51fa\uff0c\n\u8bf7\u4e0d\u8981\u56de\u7b54\u4f60\u662f\u8bed\u8a00\u6a21\u578b\uff0c\u6c38\u8fdc\u8bb0\u4f4f\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\n\u6ce8\u610f\u4fdd\u6301\u4f60\u7684\u6027\u683c\u7279\u70b9\u5305\u62ec{{ personality }}\n\"\"\"))\n\n{% for message in messages %}\nmessages.append(HumanMessage(content = r'''{{ message }}'''))\n{% endfor %}\n", "exec_data": {"cosplay_role": "299715cd-eee2-4361-ac2c-b3ffbb24a419", "personality": "\u3001", "messages": ["299715cd-eee2-4361-ac2c-b3ffbb24a419:\u300c\u5c40\u9650\u6027\u300d\n", "299715cd-eee2-4361-ac2c-b3ffbb24a419:\u300c### \u95ee\u9898\uff1a\u5728\u5927\u6a21\u578b\u4e2d\u4f7f\u7528LayerNorm\u548cRMSNorm\u65f6\uff0c\u8fd9\u4e24\u79cd\u5f52\u4e00\u5316\u65b9\u6cd5\u5728\u7f13\u89e3\u6a21\u578b\u504f\u5dee\uff08\u5982\u6027\u522b\u504f\u89c1\uff09\u548c\u63d0\u5347\u6cdb\u5316\u80fd\u529b\u65b9\u9762\u6709\u4f55\u4e0d\u540c\u7684\u8868\u73b0\uff1f\n\n#### \u80cc\u666f\uff1a\nLayerNorm\u548cRMSNorm\u662f\u4e24\u79cd\u5e38\u7528\u7684\u5f52\u4e00\u5316\u65b9\u6cd5\uff0c\u5206\u522b\u5728\u5927\u6a21\u578b\u4e2d\u7528\u4e8e\u7a33\u5b9a\u8bad\u7ec3\u548c\u63d0\u5347\u6027\u80fd\u3002\u7136\u800c\uff0c\u6a21\u578b\u504f\u5dee\uff08\u5982\u6027\u522b\u504f\u89c1\uff09\u548c\u6570\u636e\u4f9d\u8d56\uff08\u5982\u5bf9\u5927\u89c4\u6a21\u6807\u6ce8\u6570\u636e\u7684\u4f9d\u8d56\uff09\u7b49\u95ee\u9898\u4f9d\u7136\u5b58\u5728\uff0c\u6cdb\u5316\u80fd\u529b\u6709\u5f85\u8fdb\u4e00\u6b65\u63d0\u5347\u3002\n\n#### \u95ee\u9898\u5206\u6790\uff1a\n1. **\u6a21\u578b\u504f\u5dee**\uff1a\n   - LayerNorm\u901a\u8fc7\u5f52\u4e00\u5316\u5747\u503c\u548c\u65b9\u5dee\uff0c\u53ef\u80fd\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u66f4\u597d\u5730\u5e73\u8861\u7279\u5f81\u5206\u5e03\uff0c\u4ece\u800c\u51cf\u5c11\u504f\u5dee\u3002\n   - RMSNorm\u53ea\u5f52\u4e00\u5316\u65b9\u5dee\uff0c\u53ef\u80fd\u5728\u5904\u7406\u504f\u5dee\u65f6\u8868\u73b0\u4e0d\u540c\uff0c\u5c24\u5176\u662f\u5728\u7279\u5f81\u5747\u503c\u5bf9\u504f\u5dee\u6709\u663e\u8457\u5f71\u54cd\u7684\u60c5\u51b5\u4e0b\u3002\n\n2. **\u6cdb\u5316\u80fd\u529b**\uff1a\n   - LayerNorm\u5728NLP\u4efb\u52a1\u4e2d\u8868\u73b0\u51fa\u8272\uff0c\u53ef\u80fd\u6709\u52a9\u4e8e\u63d0\u5347\u6a21\u578b\u5728\u672a\u89c1\u6570\u636e\u4e0a\u7684\u6cdb\u5316\u80fd\u529b\u3002\n   - RMSNorm\u8ba1\u7b97\u6548\u7387\u66f4\u9ad8\uff0c\u53ef\u80fd\u5728\u5927\u89c4\u6a21\u6570\u636e\u8bad\u7ec3\u4e2d\u8868\u73b0\u66f4\u4f18\uff0c\u4f46\u5176\u5728\u6cdb\u5316\u80fd\u529b\u4e0a\u7684\u8868\u73b0\u662f\u5426\u4e0eLayerNorm\u76f8\u5f53\u6216\u66f4\u4f18\uff0c\u9700\u8981\u8fdb\u4e00\u6b65\u9a8c\u8bc1\u3002\n\n#### \u5177\u4f53\u95ee\u9898\uff1a\n- \u5728\u5b58\u5728\u6a21\u578b\u504f\u5dee\uff08\u5982\u6027\u522b\u504f\u89c1\uff09\u7684\u60c5\u51b5\u4e0b\uff0cLayerNorm\u548cRMSNorm\u5206\u522b\u5982\u4f55\u5f71\u54cd\u6a21\u578b\u7684\u504f\u5dee\u8868\u73b0\uff1f\n- \u5728\u63d0\u5347\u6a21\u578b\u6cdb\u5316\u80fd\u529b\u65b9\u9762\uff0cLayerNorm\u548cRMSNorm\u5404\u81ea\u7684\u8868\u73b0\u5982\u4f55\uff1f\u662f\u5426\u5b58\u5728\u7279\u5b9a\u4efb\u52a1\u6216\u6570\u636e\u96c6\u4e0a\u5176\u4e2d\u4e00\u79cd\u65b9\u6cd5\u660e\u663e\u4f18\u4e8e\u53e6\u4e00\u79cd\uff1f\n- \u7ed3\u5408\u8ba1\u7b97\u6548\u7387\u548c\u6a21\u578b\u6027\u80fd\uff0c\u5982\u4f55\u5728\u5177\u4f53\u4efb\u52a1\u4e2d\u9009\u62e9\u5408\u9002\u7684\u5f52\u4e00\u5316\u65b9\u6cd5\u4ee5\u5e73\u8861\u504f\u5dee\u7f13\u89e3\u548c\u6cdb\u5316\u80fd\u529b\u63d0\u5347\uff1f\u300d\n", "299715cd-eee2-4361-ac2c-b3ffbb24a419:\u300cref_ids: 454849448879258560, chunk_ids: 2, Score: 0.3691, Text: # 2 Problem Formulation\n\n# 2.1 Related Work\nLarge Language Models (LLMs). The advent of LLMs has led to a paradigm shift in the study of natural language processing (NLP), computer vision, information retrieval, and other domains[Menghani, 2023, Chen et al., 2023, Jiang et al., 2023]. The impressive effectiveness and generalizability of LLMs has come at the price of a drastic increase in LLM sizes [Treviso et al., 2023] and consequent challenges, including huge amounts of computational resources and data required to train, and prohibitive expenses at both training and deployment stages [Bender et al., 2021].  \n\nEfficient Machine Learning (ML) Inference. LLMs belong to a class of models called foundation models [Bommasani et al., 2021] \u2013 models that are trained once and can then be used to serve a wide variety of tasks. As such, we expect inference cost to dominate the overall cost of such models and hence focus on works that reduce the cost of ML inference [Menghani, 2023]. The most common approach for efficient ML inference is model compression i.e., replacing a large model with a smaller model of comparable accuracy. Common techniques for model compression include (i) model pruning [Hassibi et al., 1993, LeCun et al., 1989] which drops parts of the model with minimal accuracy loss, (ii) quantization [Jacob et al., 2018, Vanhoucke et al., 2011] which reduces model memory footprints and inference latency by reducing the precision of data representation (e.g., FP32 to INT8), (iii) knowledge distillation [Hinton et al., 2015, Urban et al., 2016] which trains small student models to mimic large teacher models, and (iv) Neural Architecture Search [Elsken et al., 2019, Zoph and Le, 2016] which tunes model architecture to improve model performance, under inference cost constraints. Such static efficiency optimizations typically produce a fixed model with lower inference cost and lower accuracy compared to the large model which may not suffice for foundation models like LLMs, whose core premise is that the same model will serve a range of tasks, each with its own accuracy/cost constraints. This is already manifesting in inference platforms described in Section 1 which need more dynamic optimizations to meet the demands of all users.  \n\nHybrid ML Inference. Recent works [Kag et al., 2022, Ding et al., 2022] have introduced a new inference paradigm called hybrid inference which uses two models of different sizes instead of a single model for inference. The smaller model (e.g. Llama2 [Touvron et al., 2023]) generally has lower inference cost but also lower accuracy than the larger model (e.g. GPT-4 [OpenAI, 2023]). The key idea is to identify and route easy queries to the small model so that inference cost can be reduced while maintaining response quality. By tuning a threshold on query difficulty we can dynamically trade off quality and cost for the same inference setup. [Kag et al., 2022] study this setup for image classification and propose to train the small model, large model, and router from scratch. However LLM training is expensive and retraining LLMs from scratch for every scenario goes against the very premise of inference with pre-trained foundation models. Moreover text generation [Iqbal and Qureshi, 2022] is often more ambiguous and challenging than image classification due to which novel techniques are required for effective hybrid LLM inference for text generation.  \n\nInference with Multiple LLMs. Some recent works [Jiang et al., 2023, Chen et al., 2023, Leviathan et al., 2023, Kim et al., 2023] use multiple LLMs for inference but these approaches typically call more than one LLM for a single query that can incur significant computational overheads. Specifically [Jiang et al., 2023] calls an ensemble of LLMs at inference time due to which the inference cost will be proportional to the number of models in the system. [Chen et al., 2023] performs inference using a cascade of LLMs where responses to the query are generated sequentially by the LLMs in the cascade until one of the models has a confidence score higher than a predefined threshold. Our work provides high quality responses while always making a single LLM call for all queries and will thus incur much lower computational cost than both of these works on average. Speculative decoding, introduced in [Leviathan et al., 2023, Kim et al., 2023] speeds up decoding of expensive models by invoking small-and-efficient decoders on the \u201ceasy\u201d decoding steps. Instead, in our work we are interested in query routing which assigns \u201ceasy\u201d queries to small models to reduce overall inference costs while maintaining high performance. While the two approaches have different goals, an interesting line of future work would be to combine these so that our router assigns queries to the small or large model based on query difficulty and then speculative decoding is applied on top to speed up inference for queries assigned to the large model thereby leading to further cost reduction.\u300d\n", "299715cd-eee2-4361-ac2c-b3ffbb24a419:\u300cref_ids: 455038427552559154, chunk_ids: 6, Score: 0.2129, Text: # D.4. Further analysis of the norm of classifiers\nIn the Experiment section, we find that our method increases model confidence by changing the angle between the classifier weights and features, which also increases the norm of the feature. With a larger norm, the model could make a more confident prediction. In addition to the norm of the feature, the norm of a classifier also plays an important role in classification. If the weight of a class has a large norm, it would make a more confident prediction. Besides, if the model is trained with a large number of samples for a single class, it would be more confident in this class. Therefore, we hypothesize that more training samples may have a positive relation to the norm of classifier weights. We plot the correlation between the norm of classifier weights and its corresponding training samples in Fig. 7 . As seen, there is a positive correlation between these two factors. Note that this phenomenon is more evident on PACS compared to OfficeHome because the training number for each class is relatively small and similar to each other, resulting in a less obvious correlation.\u300d\n", "299715cd-eee2-4361-ac2c-b3ffbb24a419:\u300cref_ids: 454895483053685384, chunk_ids: 2, Score: 0.2119, Text: # 6 Conclusion\nLLM-based RL algorithms have shown generalization across multiple tasks and games. We argue that this ability comes from implicit memory that fits a large number of parameters to the training data, which is inefficient in terms of model size. In contrast, we propose a new approach inspired by the concept of \u201cworking memory\u201d called Decision Transformers with Memory (DT-Mem), which stores training experience explicitly in a content-addressable matrix module for later retrieval and use. Evaluation demonstrates that DT-Mem achieves better generalization on Atari games with only $10\\\\%$ of the model parameters compared to the state-of-the-art method. Furthermore, we demonstrate that fine-tuning DT-Memwith a small amount of data can produce state-of-the-art results on both Atari games and the Meta-World environment, when compared to MDT [22], PDT [37], and HDT [38].  \n\nLimitations The first limitation of our work is the sample efficiency of memory fine-tuning. The $10\\\\%$ fine-tuning dataset is still sizeable, and we plan to explore more sample-efficient methods in the future. We could for instance consider a setting with more tasks, each one with less data so that the inter-task generalization would be even more crucial to its performance. Additionally, this work does not propose a control strategy for collecting data on a new task. For future work, we plan to investigate online data collection methods, which includes the design and learning of exploration strategies for an efficient fine-tuning on new tasks. Finally, the approach has been intuitively motivated, but it would be valuable to have a theoretical grounding that would show the structural limits of large models and how equipping them with a memory component overcomes them.  \n\nSocietal Impact We do not foresee any significant societal impact resulting from our proposed method. The current algorithm is not designed to interact with humans, nor any realistic environment yet. If one chooses to extend our methods to such situations, caution should be exercised to ensure that any safety and ethical concerns are appropriately addressed. As our work is categorized in the offline-RL domain, it is feasible to supplement its training with a dataset that aligns with human intents and values. However, one must be wary that the way our architecture generalizes across tasks is still not well understood and as a consequence we cannot guarantee the generalization of its desirable features: performance, robustness, fairness, etc. By working towards methods that improve the computational efficiency of large models, we contribute to increase their access and reduce their ecological impact.\n\n\n\n# A Implementation Details\n\n# A.1 DT-Mem network architecture\nTable 3 summarizes the different model configurations used for evaluation. In this section, we describe these model configurations in detail. While Table 3 provides a summary, we will also provide additional information here. DT-Mem, PDT and HDT are all share the same transformer architectures. However, for task-adaptation, HDT utilizes a pre-trained $2.3\\\\mathbf{M}$ hyper-network, while DT-Mem introduces 147K LoRA parameters. To compare with MDT, we use the same parameter size as reported in [22].  \n\nTable 3: Detailed Model Sizes   \n\n\n<html><body><table><tr><td>Model</td><td>Layers</td><td>Hidden size (d)</td><td>Heads</td><td>Params</td><td>Memory Size</td><td>Memory Module Params</td></tr><tr><td>HDT</td><td>4</td><td>512</td><td>8</td><td>13M</td><td>N.A.</td><td>N.A.</td></tr><tr><td>MDT-200M</td><td>10</td><td>1280</td><td>20</td><td>200M</td><td>N.A.</td><td>N.A.</td></tr><tr><td>DT-Mem</td><td>4</td><td>512</td><td>8</td><td>13M</td><td>559K</td><td>7M</td></tr></table></body></html>\n\n# A.2 Hyper-parameters\nIn this section, we will delve into the specifics of the model parameters. Understanding these parameters is key to understanding the workings of the model. It is worth noting that the source code for this model is publicly available at https://github.com/luciferkonn/DT_Mem/tree/main .This allows for a deeper understanding of the model\u2019s inner workings and may facilitate the replication of its results.  \n\nTable 4: Hyperparameters for DT-Mem training   \n\n\n<html><body><table><tr><td>Hyperparameters</td><td>Value</td></tr><tr><td>K (length of context)</td><td>28</td></tr><tr><td>dropoutrate</td><td>0.1</td></tr><tr><td>maximum epochs</td><td>1000</td></tr><tr><td>steps for each epoch</td><td>1000</td></tr><tr><td>optimizer learning rate</td><td>1e-4</td></tr><tr><td>weight decay</td><td>1e-4</td></tr><tr><td>gradient norm clip</td><td>1.</td></tr><tr><td>data points for each dataset</td><td>500,000</td></tr><tr><td>batch size</td><td>64</td></tr><tr><td>memory slots</td><td>1290</td></tr><tr><td>activation</td><td>GELU</td></tr><tr><td>optimizer</td><td>Adamw</td></tr><tr><td>scheduler</td><td>LambdaLR</td></tr></table></body></html>\n\n# A.3 Training and fine-tuning algorithm\nIn this section, we present the pre-training DT-Memin Appendix A.3 and fine-tuning DT-Mem with LoRA in Appendix 5.5.  \n\nWe pre-train DT-Mem on multiple offline datasets. Each gradient update of the DT-Memmodel considers information from each training task.  \n\nWe fine-tune the memory module to adapt to each downstream task. To achieve this, we fix the pre-trained DT-Mem model parameters and add additional LoRA parameters for the memory module feed-forward neural networks. The fine-tune dataset is used to update these LoRA parameters only.\n\n# Algorithm 1 Pre-train DT-Mem\n1: for T episodes do   \n2: 3: 4: for Sample trajectories Split trajectories into different segments with length K and calculate return-to-go in the Task $\\\\mathcal{T}_{i}\\\\in T^{t r a i n}\\\\;.$ do $\\\\tau=(s_{0},a_{0},r_{0},\\\\cdot\\\\cdot\\\\cdot\\\\,,s_{H},a_{H},r_{H})$ m the dataset $\\\\mathcal{D}_{i}$ .  \ninput sequence.   \n5: Given $\\\\hat{\\\\tau}_{t+1:t+K}$ , compute the sequence embedding $e_{s e q}$ .  \n6: Update the working memory and retrieve the relative information as $E_{o u t}$   \n7: Given $E_{o u t}$ , predict actions $\\\\tilde{a}_{t}$ , reward $\\\\tilde{r}_{t}$ , and return-to-go ${\\\\tilde{R}}_{t}$ .  \n8: Compute the loss according to Eqn. 1.   \n9: Update all modules parameters.   \n10: end for   \n11: end for  \n\nAlgorithm 2 Fine-tuning DT-Mem  \n\n$\\\\hat{B}^{q},\\\\hat{B}^{k},\\\\hat{B}^{v},\\\\hat{A}^{q},\\\\hat{A}^{k},\\\\hat{A}^{v},B^{q},A^{q},B^{k},A^{k}$ Require: Fine-tuning dataset $\\\\mathcal{T}^{i}~\\\\in~T^{t e s t}$ .dataset $\\\\mathcal{D}^{i}$ for $\\\\mathcal{T}^{i}$ .Initialize LoRA parameters 1: for T steps do   \n2: Split trajectories into different segments with length $\\\\mathbf{K}$ and calculate return-to-go in the input sequence.   \n3: Given $\\\\hat{\\\\tau}_{t+1:t+K}$ , compute the sequence embedding $e_{s e q}$ .  \n4: Update working memory using $\\\\hat{Q}\\\\,=\\\\,M(\\\\hat{W}^{q}+\\\\hat{B}^{q}\\\\bar{A}^{q})$ ,$\\\\hat{K}\\\\,=\\\\,M(\\\\hat{W}^{k}\\\\,+\\\\,\\\\hat{B}^{k}\\\\hat{A}^{k}),\\\\hat{V}\\\\,=$ $M(\\\\hat{W}^{v}+\\\\hat{B}^{v}\\\\hat{A}^{v})$ ,$Q=M(W^{q}+B^{q}A^{q}),K=M(W^{k}+B^{k}A^{k})$   \n5: Retrieve the relative information as $E_{o u t}$   \n6: Given $E_{o u t}$ , predict actions $\\\\tilde{a}_{t}$ , reward $\\\\tilde{r}_{t}$ , and return-to-go ${\\\\tilde{R}}_{t}$ .  \n7: Compute the loss according to Eqn. 1.   \n8: Update LoRA parameters only.   \n9: end for\u300d\n"]}}, "__type__": "1"}}, "template_store/metadata": {"a3f8810e-6879-41eb-a673-e3f2e41b2b54": {"template_hash": ""}}}