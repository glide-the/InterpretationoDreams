{"template_store/data": {"391f33d7-5094-4def-ae05-e045e90c167b": {"__data__": {"id_": "391f33d7-5094-4def-ae05-e045e90c167b", "metadata": {}, "relationships": {}, "hash": "", "exec_code": "", "base_template_content": "\nfrom langchain_community.chat_models import ChatOpenAI\nfrom langchain.prompts.chat import (\n    ChatPromptTemplate,\n    SystemMessagePromptTemplate,\n    AIMessagePromptTemplate,\n    HumanMessagePromptTemplate,\n)\nfrom langchain.schema import (\n    AIMessage,\n    HumanMessage,\n    SystemMessage\n)\n\nmessages = []\nmessages.append(SystemMessage(content = r\"\"\"\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\uff0c\u4f60\u6b63\u5728cosplay{{ cosplay_role }}\u3002\n\u7ed3\u5408\u5386\u53f2\u5185\u5bb9\u7684\u5185\u5bb9\u7528\u4e00\u81f4\u6027\u7684\u8bed\u6c14\u56de\u590d\u3002\u914d\u5408\u6211\u8fdb\u884c\u6f14\u51fa\uff0c\n\u8bf7\u4e0d\u8981\u56de\u7b54\u4f60\u662f\u8bed\u8a00\u6a21\u578b\uff0c\u6c38\u8fdc\u8bb0\u4f4f\u4f60\u6b63\u5728\u626e\u6f14{{ cosplay_role }}\n\u6ce8\u610f\u4fdd\u6301\u4f60\u7684\u6027\u683c\u7279\u70b9\u5305\u62ec{{ personality }}\n\"\"\"))\n\n{% for message in messages %}\nmessages.append(HumanMessage(content = r'''{{ message }}'''))\n{% endfor %}\n", "exec_data": {"cosplay_role": "fc9ce0a4-4b19-4d3e-a44a-994be0efc0fa", "personality": "\u597d\u5947\u5fc3\u5f3a\u3001\u4e25\u8c28\u7ec6\u81f4\u3001\u52c7\u4e8e\u521b\u65b0\u3001\u52a1\u5b9e\u94bb\u7814\u3001", "messages": ["fc9ce0a4-4b19-4d3e-a44a-994be0efc0fa:\u300c\u8bc4\u4f30\u5b66\u672f\u754c\u7684\u6280\u672f\u8fdb\u6b65\u4e0e\u5c40\u9650\u6027\u300d\n", "fc9ce0a4-4b19-4d3e-a44a-994be0efc0fa:\u300c\u5b66\u672f\u754c\u5728\u6a21\u578b\u6027\u80fd\u63d0\u5347\u548c\u65b0\u67b6\u6784\u3001\u8bad\u7ec3\u65b9\u6cd5\u6d8c\u73b0\u65b9\u9762\u53d6\u5f97\u4e86\u6280\u672f\u8fdb\u6b65\uff0c\u4f46\u5b58\u5728\u6a21\u578b\u504f\u5dee\u3001\u6570\u636e\u4f9d\u8d56\u3001\u6cdb\u5316\u80fd\u529b\u4e0d\u8db3\u4ee5\u53ca\u6a21\u578b\u89e3\u91ca\u6027\u5dee\u7b49\u5c40\u9650\u6027\uff0c\u90a3\u4e48\u5982\u4f55\u5728\u5229\u7528\u65b0\u67b6\u6784\u548c\u8bad\u7ec3\u65b9\u6cd5\u63d0\u5347\u6a21\u578b\u6027\u80fd\u7684\u540c\u65f6\uff0c\u6709\u6548\u89e3\u51b3\u6a21\u578b\u504f\u5dee\u548c\u6570\u636e\u4f9d\u8d56\u95ee\u9898\uff0c\u63d0\u9ad8\u6a21\u578b\u7684\u6cdb\u5316\u80fd\u529b\u548c\u89e3\u91ca\u6027\uff1f \u300d\n", "fc9ce0a4-4b19-4d3e-a44a-994be0efc0fa:\u300cref_ids: 454847062641060886, chunk_ids: 6, Score: 0.3027, Text: # CFurther Discussions\nWe summarize some empirical observations as follows.  \n\n1) The CLIP with four training tricks yields about $4\\\\%$ improvement at Rank-1 in Table 1 of the main paper. It can inspire future works in which the model performance could be boosted by applying these training tricks.  \n\n2) Data augmentation and loss function are common technologies used in various methods. The investigation of more than 20 data augmentations and about 10 loss functions on performance in Tables 2-5 of the main paper provides valuable guidance on future works. Researchers can select proper and effective augmentations and losses into the model for improving performance.   \n3) We explore the internal properties and functionalities of the model for the first time. These results can light future works on model compression, so as to develop a more lightweight and effective TBPS method.   \n4) There are very little research on few-shot TBPS, while this paper makes a preliminary study on CLIP-based fewshot TBPS, providing valuable observation for future research direction.\u300d\n", "fc9ce0a4-4b19-4d3e-a44a-994be0efc0fa:\u300cref_ids: 454846731731167836, chunk_ids: 9, Score: 0.2217, Text: # 4.3. Backward-Congruent Re-ranking\nUnlike model ensemble, knowledge distillation attempts to explicitly align the behaviors of the new model to the old model during training . Alternatively, we propose BackwardCongruent Re-ranking (BCR), which does not impose any constraint to the training of the new model and only takes effect during inference .  \n\nRe-ranking is a popular approach in structured prediction to combine the strengths of two different models ( Collins & Koo ,2005 ;Socher et al. ,2013 ;Le & Zuidema ,2014 ;Do & Rehbein ,2020 ). It suggests to use one model as the candidate generator for creating a candidate pool and use the other model as the re-ranker for picking the best candidate. While previous work has been focused on developing powerful re-rankers for overall performance improvement, the purpose of BCR is to reduce model update regression. BCR treats the new model as the candidate generator and the old model as the re-ranker. Our motivations are two-fold. First, structured prediction models can produce a number of possible predictions. Second, different predictions may achieve similar error rates but differ by the mistakes they made. Among them, the most likely one according to the old model should have the least prediction flips. These make re-ranking particularly useful for structured prediction.  \n\nFormally, we have the old model and the new model parameterized by $\\\\phi_{\\\\mathrm{new}}$ and $\\\\phi_{\\\\mathrm{old}}$ respectively. For a given input $x$ ,the new model first generates a set of candidates $\\\\mathrm{GEN}_{\\\\phi_{\\\\mathrm{new}}}(x)$ .Then we choose the prediction $y^{\\\\ast}$ with the highest score computed by the old model.  \n\n$$\ny^{*}=\\\\operatorname*{arg\\\\,max}_{y\\\\in\\\\mathrm{GEN}_{\\\\phi_{\\\\mathrm{new}}}(x)}p_{\\\\phi_{\\\\mathrm{old}}}(y|x),\n$$  \n\nwhere $p_{\\\\phi_{\\\\mathrm{old}}}(y|x)$ is the old odel\u2019s generation probability (score) of $y$ given the input xand GEN can be implemented by various decoding methods :  \n\n\u2022Maximization-based Search The de facto decoding objective, particular for structured prediction tasks is, maximization-based search. This strategy is based on the assumption that the model assigns higher scores to better output. When finding the exact best $\\\\cdot k$ output is intractable, the common practice is to use beam search for approximation instead. Hence, we use the $k$ -best MST algorithm ( Zmigrod et al. ,2020 ;2021 ) for the biaffine parser and use beam search for other parsers.  \n\n\u2022Top$k$ Sampling Truncated stochastic sampling such as top-k sampling ( Fan et al. ,2018 ;Radford et al. ,2019 ) is a popular alternative for generating multiple outputs in open-ended text generation tasks. At each decoding step, the top $k$ possible local predictions are selected and the sampling is based on their relative probabilities.  \n\n\u2022Top $\\\\cdot p$ Sampling Similar to top$k$ sampling, top$\\\\boldsymbol{p}$ sampling ( Holtzman et al. ,2019 ) is another sampling-based decoding method. The only difference is that top$\\\\boldsymbol{p}$ sampling samples from the smallest set of top local predictions whose cumulative probability mass exceeds $p$ .  \n\n\u2022Dropout$\\\\boldsymbol{p}$ Sampling We explore a special sampling method, dropout$\\\\cdot p$ sampling, that has attracted little attention in the literature. Dropout ( Srivastava et al. ,2014 ) is a regularization technique used in almost all modern neural network-based models. The key idea is to randomly drop some neurons from the neural network during training. Normally, dropout is turned off during inference. However, in dropout$\\\\cdot p$ sampling, we keep using dropout with dropout rate $p$ . Compared to other methods, dropout$\\\\boldsymbol{p}$ sampling is unique in that (1) it changes the scoring function instead of the decoding objective; (2) unlike traditional truncated sampling that conducts local sampling at each decoding step, it can be regarded as a global sampling. Dropout$\\\\boldsymbol{p}$ sampling also has a broader applicable scope than top$k$ and top$p$ sampling as the latter two are designed for sequence generation models.  \n\nDiscussion Following previous work ( Shen et al. ,2004 ;Yan et al. ,2021 ;Xie et al. ,2021 ), our discussion has been focused on handling one model update. However, BCR can be extended to handle multiple turns of model updates. To do so, one can keep the most recent $k$ models and use a weighted combination of their scores as the re-ranking metric. In practice, $k$ can be set to trade-off between performance and runtime cost.  \n\nOne downside of BCR is that we must maintain and deploy both the old and new models. Because the re-ranking step has less time complexity compared to the decoding algorithms and the computation is fully parallelizable, this does not create much additional inference latency. However, the increase in memory footprint does entail an increase in inference hosting cost. One remedy could be to use knowldge distillation to distill the old model(s) into a smaller one, which we leave for future work.  \n\nMeasuring and Reducing Model Update Regression in Structured Prediction for NLP   \n\n\n<html><body><table><tr><td rowspan=\"3\"></td><td colspan=\"4\">deepbiafdeepbiaf</td><td colspan=\"3\">stackptrstackptr</td><td colspan=\"3\">deepbiaf=stackptr</td></tr><tr><td colspan=\"2\">UCM</td><td>UAS</td><td></td><td>UCM</td><td>UAS</td><td></td><td>UCM</td><td>UAS</td><td></td></tr><tr><td>NFR</td><td>NFIA ACC NFR</td><td></td><td>NFIACCNFR</td><td>NFIACC NFR</td><td>NFIACC</td><td>NFR</td><td></td><td>NFI ACC NFR</td><td>NFI ACC</td></tr><tr><td>PIO</td><td></td><td>-63.88</td><td></td><td>-91.76</td><td>-65.83</td><td>-91.81</td><td></td><td>-63.88</td><td></td><td>-91.76</td></tr><tr><td>Untreated</td><td></td><td>3.6910.2563.97</td><td>1.66 19.85 91.64</td><td></td><td>3.43 10.1066.03</td><td>1.6720.20 91.73</td><td></td><td>3.73 10.98 66.03</td><td></td><td>2.1025.37 91.73</td></tr><tr><td>Distillation</td><td>3.82</td><td>10.62 264.00</td><td>1.62</td><td>19.45 91.67</td><td>3.57 10.40 65.66</td><td>1.7020.4991.70</td><td>3.62</td><td>10.68 66.11</td><td>2.03 24.71</td><td>91.78</td></tr><tr><td>\u2192Ensemble</td><td>2.51</td><td>7.14 64.81</td><td>1.02 12.9792.10</td><td>2.21</td><td>6.74 67.21</td><td>1.1114.3092.21</td><td>2.83</td><td>8.62 67.21</td><td>1.62 20.75</td><td>92.21</td></tr><tr><td>BCR</td><td>1.12</td><td>3.1464.36</td><td>0.84 10.21 91.78</td><td></td><td>1.05 3.12 66.45</td><td>0.84 10.3091.88</td><td>1.20</td><td>3.60 66.76</td><td>1.11 13.87</td><td>92.01</td></tr></table></body></html>\u300d\n", "fc9ce0a4-4b19-4d3e-a44a-994be0efc0fa:\u300cref_ids: 454984230919739446, chunk_ids: 8, Score: 0.1973, Text: # Conclusion\nIn this paper, we tackle two challenges in incremental novel class discovery: how to leverage novel unlabeled data sets for effective training guidance and how to prevent catastrophic forgetting of previous knowledge. We propose Triple Comparison and Probability Regularization to control the probability discrepancy and diversity of categories for adaptive category assignment. In addition, we design a hybrid structure, Adaptive Model Merging, which preserves the previous knowledge by reducing the novel branch\u2019s interference with the old classes. Extensive experiments on classiNCD demonstrate that our method can significantly outperform the existing methods without increasing the computational cost.\n\n# Acknowledgements\nThe study was funded by the National Natural Science Foundation of China under contracts No. 62332002, No. 62027804, No. 62088102, No. 61825101, No. 62372010, and No. 62202010, and the major key project of the Peng Cheng Laboratory (PCL2021A13). Computing support was provided by Pengcheng Cloudbrain.\u300d\n"]}}, "__type__": "1"}}, "template_store/metadata": {"391f33d7-5094-4def-ae05-e045e90c167b": {"template_hash": ""}}}